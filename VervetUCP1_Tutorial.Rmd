---
title: "Vervet UCP1 Analysis"
author: "Christopher A Schmitt and Christian M Gagnon"
date: "May 1, 2019"
output: html_document
---

```{r,echo=F}
library(knitr)
```

```{css,echo=F}
.sccCode {
background-color: black;
  color: white;
}
```

Here's some code to initate a gene analysis using the International Vervet Research Consortium's worldwide genome dataset. This will be done in the *SCC* workspace at BU, as part of the *vervpop* Project.

NOTE: There will be both *R* and unix code here. The *SCC* is accessible through a unix-based terminal, while *R* code will be executed within that space using an *R Studio* module. The code chunks in this tutorial are colored according to the workspace: black code chunks are meant to be executed in the *SCC* workspace, while grey code chunks are meant to be executed in *R/Rstudio*. All files are available in the *vervpop* project space on the *SCC*, or in the external hard-drives in the SMGAL lab computers (e.g., '*hilgerti*' or '*pygerythrus*').

ALSO NOTE: This code is for a Mac OSX machine. It may be slightly different for a Windows interface.

###Getting Ready

Version Control: 
vcfR 1.8.0
adegenet 2.1.1
ggplot2 3.1.1
vegan 2.5-4
poppr 2.8.2
dplyr 0.8.0.1
Matrix 1.2-17
hierfstat 0.04-22
reshape 0.8.8
pwr 1.2-2
pegas 0.11
VariantAnnotation 1.28.13
snpStats 1.32.0
VariantAnnotation 1.28.13
LDheatmap 0.99-5
GenomicFeatures 1.34.8
RMariaDB 1.0.6
PopGenome 2.6.1
rehh 2.0.4
ips 0.0.7
ape 5.3
phangorn 2.5.3
phytools 	0.6.60
geiger 	2.0.6.1


##Introduction
Uncoupling proteins (UCPs) are all induced by fatty acids, and are known to perform important metabolic functions in humans. UCP1 is the most widely studied of the UCPs, and contributes to non-shivering thermogenesis and metobolic promotion of healthy body weight. The functions of the other UCP genes (2-5) are less well known, but are hypothesized to have a role in resting energy expenditure, contributing more in lipid regulation as fuel than thermoregulation. The goal of this study analyzes population structure of UCP1 in various sample populations of vervets (Chlorocebus), making up a Southern Expansion meta-population. We also aim to investigate potential signs of selection within the UCP1 region of three vervet subspecies Pygerythrus, Cynosuros, and Hilgerti sub-species. We further separated the Pygerythrus sub-species into three populations according to the regions from which the individuals were sampled. We hypothesize that there would be strong differentiation between populations sampled from areas geographically far from one another, and that there would be signs of selection in the UCP1 region of populations sampled from South Africa, where the environmental conditions are the most extreme. 

First, let's get to our workspace by logging in to the *SCC*. If you have a *vervpop* login, use that where you see 'caschmit' (it should be your BUID login). If you don't have a login for the *SCC*, contact Dr. Schmitt:
```{bash, eval = F, echo = T, class.source="sccCode"}
ssh -Y caschmit@scc1.bu.edu
```

Enter your password, you should be automatically logged in to the *vervpop* space. Once there, navigate to the *vervpop* folder, which contains our files of interest:

```{bash, eval = F, echo = T, class.source="sccCode"}
cd vervpop
```

The vervet population genomics data has been downloaded as a gunzipped VCF file in the *vervpop* folder called "**163_201701_UG_vervet_monkey_SNPs_all_chrom_beagle_shapeit.vcf.gz**". You can get more information by reading the associated 'README' file. This data was initially published as a part of a larger paper on genomic variation in vervets published by published in [Svardal et al. (2017)](https://www.nature.com/articles/ng.3980), and so more information about the dataset can be found in that paper and its associated supplemental materials.

##Isolating Your Gene of Choice (Example: *UCP1*)

Our first task will be to isolate the *UCP1* gene region from the whole genome data, to make the amount of data more manageable. To do this, we'll use *tabix*:
```{bash, eval = F, echo = T, class.source="sccCode"}
module load tabix
```

##UCP1 Coordinates
Hg38 UCP1 coordinates (UCSC)
chr4:140,559,434-140,568,805
Hg38 UCP1 coordinates (Ensembl)
chr4:140,559,431-140,568,961
Vervet UCP1 coordinates (UCSC convert)
chr7:87,492,140-87,502,530
Vervet UCP1 coordinates (Ensembl)
chr7:87,492,195-87,502,665
Vervet UCP1 +/- 10k 
chr7:87,482,195-87,512,665
Rhesus macaque 10k
chr5:140,601,940-140,632,450

Now, based on the ChlSab1.1 reference genome (available and searchable on the [*Ensembl Genome Browser*](https://useast.ensembl.org/Chlorocebus_sabaeus/Info/Index)), the *UCP1* gene region in the vervet is on chromosome 7, with the following positions: **7:87,492,195-87,502,665**. We added 10k base pairs to each end of the gene in order to capture any up or downstream regulatory regions.

First, we need to isolate each of the UCP1 gene  from the vervet genome data. Then, we will isolate them for the three taxa of the Southern Expansion populations: Cynosuros, Hilgerti, and Pygerythrus. We will also isolate the genes separately for cynosuros and pygerythrus for finding neutrality statistics to look for selection (we are not doing this for hilgerti because there are too few samples). Lastly, we will get a list of variants from each isolated gene to use for our linkage disequillibrium tests. We're going to do this all using the tabix module on the SCC: 

Let's use *tabix* to separate out that full gene region, **along with potential regulatory regions 10kb up and downstream of the gene**, and call it ***vervUCP1.full.vcf***. Note, here, that in the dataset we have downloaded each chromosome name is not simply the number, but 'CAE' appended to the number (i.e., for chromosome 7, instead of '7' it's 'CAE7'):

##Download vervet .vcf and index to directory
```{bash}
wget https://vervetmonkeygmi.blob.core.windows.net/publicationdata/163_201701_UG_vervet_monkey_SNPs_all_chrom_beagle_shapeit.vcf.gz
wget https://vervetmonkeygmi.blob.core.windows.net/publicationdata/163_201701_UG_vervet_monkey_SNPs_all_chrom_beagle_shapeit.vcf.gz.tbi
```

```{bash, eval = F, echo = T, class.source="sccCode"}
tabix -h 163_201701_UG_vervet_monkey_SNPs_all_chrom_beagle_shapeit.vcf.gz CAE7:87492195-87502665 > vervUCP1.full.vcf
```

If you're using a SMGAL computer attached to *hilgerti*, you can also use this code:
```{bash,eval=F,echo=T,class.source="sccCode"}
tabix -h /Volumes/hilgerti/vervVCFwild/163_201701_UG_vervet_monkey_SNPs_all_chrom_beagle_shapeit.vcf.gz CAE7:87482195-87512665 | bgzip -c > vervUCP1.vcf.gz
```

Let's take a look and make sure everything downloaded ok:
```{bash,eval=F,echo=T, class.source="sccCode"}
gunzip -c vervUCP1.vcf.gz | less
```

Let's also take a quick and dirty look at how many variant calls we have in this gene region:

```{bash, eval = F, echo = T, class.source="sccCode"}
wc -l vervUCP1.full.vcf
grep -c "^##" vervUCP1.full.vcf
```

Ok, that's 865  lines in the VCF file, only 38 of which are metadata headlines! That means there are 827 variant calls in the *UCP1* gene region, and for 163 individual vervets! That's great! Humans have about 208 in the gene alone, so we've got a lot to work with.

###Exonic Regions of *UCP1*

Now, for a little more information on this genomic region, we can look to *Ensembl* to understand more about the structure of this gene. We can get the positions of the exonic regions from the vervet reference genome on *Ensembl* (you can click the *6 exons* hyperlink in the *About this transcript* subsection of the *Transcript UCP1-201* tab; they're in red on the sequence output, and positions are listed if you look at the transcript table). They include the following positions:

* CAE7:87502451-87502329 (not including UTR)
* CAE7:87501718-87501520
* CAE7:87496233-87496033
* CAE7:87495927-87495826
* CAE7:87495081-87494901
* CAE7:87492718-87492611 (not including UTR)

There are some functions/programs, like PAML, that only analyze exonic regions, so knowing this can come in handy!

##HWE in *UCP1*

Now, let's look at variation in the whole gene region, starting with some HWE tests.

Now, before actually doing this, we should divide the vervets into their respective populations based on ID. We can do this using a population panel file, like in 1000 Genomes. I'll create one using a text editor and the supplemental data from Svardal et al. (2017) and store it in the *vervpop* folder, called ***vervet.population.panel***. Once that's available, we can filter by whichever variable we choose!

For example, to get a sample of vervets only found in the taxon *pygerythrus*:

```{bash, eval = F, echo = T, class.source="sccCode"}
grep pygerythrus vervet.population.panel | cut -f1 > pyg.samples.list
```

For Southern Expansion (**pygerythrus*,*cynosuros*, and *hilgerti*)
NOTE: We also need to go into this file and take out the two vervets from Botswana, which are technically *Ch. pygerythrus*, but genomically cluster within the *Ch. cynosuros* population. To do that, I recommend opening the the `pyg.samples.list` file in `gedit` and simply deleting the names beginning with `VBO`. You can open the file in `gedit` using this code:
```{bash, eval = F, echo = T, class.source="sccCode"}
gedit pyg.samples.list
```

Once the Botswana samples are deleted, we can use *vcftools* to create a VCF with just the samples comprising the South African *pygerythrus*:

```{bash, eval = F, echo = T, class.source="sccCode"}
module load vcftools
vcftools --vcf vervUCP1.full.vcf --keep pyg.samples.list --recode --out pygUCP1
mv pygUCP1.recode.vcf pygUCP1.vcf
```

This will create a file called ***pygUCP1.vcf*** that only has the variants called for *UCP1* within our South African *Ch. pygerythrus* sample. 

For Southern Expansion (*pygerythrus*,*cynosuros*, and *hilgerti*) simply create samples lists for *cynosuros* and *hilgerti* and combine into one document named se.samples.list. Also, no need to remove the botswana samples in this case:

```{bash}
grep pygerythrus vervet.population.panel | cut -f1 > pyg.samples.list
grep cynosuros vervet.population.panel | cut -f1 > cyn.samples.list
grep hilgerti vervet.population.panel | cut -f1 > hil.samples.list
```

```{bash, eval = F, echo = T, class.source="sccCode"}
module load vcftools
vcftools --vcf vervUCP1.full.vcf --keep se.samples.list --recode --out seUCP1
mv seUCP1.recode.vcf seUCP1.vcf
```

Let's see if these variants are in HWE. To do so, first we can go to our *R* space and run a quick power test to see if the number of samples we have is even enough to see anything:
```{r,eval=F,echo=T}
library(pwr)
pwr.chisq.test(w = 0.5, df = 1, sig.level = 0.05, power=0.95)
```

Hmmm... the above equation is for 52 samples (we have 49 for *pygerythrus* and 81 in the southern expansion). After playing around a bit, it looks like we'd really need a pretty big effect size (0.5) to see a statistically strong result given our sample size. BUT this is the data we have, so let's try anyway!

```{bash, eval = F, echo = T, class.source="sccCode"}
module load vcftools
vcftools --vcf /Users/christiangagnon/Documents/pyg_ihs/pyg_UCP1.vcf --hardy --out pygUCP1
less pygUCP1.hwe
```

Ok! We actually have significant deviations from HWE for the following variants in the *Ch. pygerythrus* sample (genotype proportions are hom1/het/hom2):

* CAE7:87483454 (p = 0.0437; 15/17/17): 3' downstream
* CAE7:87483771 (p = 0.0437; 15/17/17): 3' downstream
* CAE7:87483956	(p = 0.0218; 43/4/2): 3' downstream
* CAE7:87492384 (p = 0.0062; 31/11/7): This is in the 3' UTR region
* CAE7:87492801 (p = 0.0437; 15/17/17): Intronic (5-6) variant
* CAE7:87492842 (p = 0.0166; 30/12/7): Intronic (5-6) variant
* CAE7:87493023 (p = 0.0436; 17/17/15): Intronic (5-6) variant
* CAE7:87496971 (p = 0.0090; 19/15/15): Intronic (2-3) variant
* CAE7:87497024 (p = 0.0438; 32/12/5): Intronic (2-3) variant
* CAE7:87497539	(p = 0.0615; 46/2/1: Intronic (2-3) variant
* CAE7:87497809 (p = 0.0207; 18/16/15): Intronic (2-3) variant
* CAE7:87497815 (p = 0.0437; 15/17/17): Intronic (2-3) variant

Note that where in the gene these positions are found can be determined following the same directions as above to find the exonic regions.

Also remember, these are from multiple populations that may be separated by mating barriers (especially KZN relative to Free State samples).

For the intronic variants, these might be influential for splices, or expression... we should check out what their orthologs are in humans!

###HWE in Southern Expansion

```{bash, eval = F, echo = T, class.source="sccCode"}
module load vcftools
vcftools --vcf seUCP1.vcf --hardy --out seUCP1
less seUCP1.hwe
```

Analysis in R:
```{r}
library(vcfR)
library(pegas)
#UCP1
UCP1 <- read.vcfR("~/Desktop/594_final/se_UCP1.vcf.gz", verbose = TRUE) #Read in data
pegas.UCP1 <- vcfR2genind(UCP1, sep = "[|/]") #Use pegas to perform analysis
HWE <- hw.test(pegas.UCP1, B = 0) #copy output to new file called HWE
HWE #View output

```

###HWE in *Ch. sabaeus*

Now, the only other populations with sequenced samples that might be big enough to actually detect relevant SNPs using would be the West African and Caribbean *Ch. sabaeus* populations. It might also be interesting to look for differences in variation between them because 1) the Caribbean population is an inbred bottleneck of the West African, and 2) the Caribbean population is also in a more temperate - if still tropical - latitude (we'd have to actually check the climatic data to see if there's a significant difference).

Let's see if there are variants out of HWE in those two populations:

```{bash, eval = F, echo = T, class.source="sccCode"}
grep Caribbean vervet.population.panel | cut -f1 > sabCB.samples.list
grep Gambia vervet.population.panel | cut -f1 > sabWA.samples.list
```

Looks like we have 39 Caribbean vervets sequenced, and 22 West African... not as good a sample as in South Africa.

```{bash, eval = F, echo = T, class.source="sccCode"}
module load vcftools
vcftools --vcf vervUCP1.full.vcf --keep sabCB.samples.list --recode --out sabCB_UCP1
mv sabCB_UCP1.recode.vcf sabCB_UCP1.vcf

vcftools --vcf vervUCP1.full.vcf --keep sabWA.samples.list --recode --out sabWA_UCP1
mv sabWA_UCP1.recode.vcf sabWA_UCP1.vcf
```

Let's take a look:

```{bash, eval = F, echo = T, class.source="sccCode"}
vcftools --vcf sabCB_UCP1.vcf --hardy --out sabCB_UCP1
less sabCB_UCP1.hwe
```

Only one variant in this population is significantly out of HWE, surprising given there must be a large amount of genetic drift in the Caribbean population:

* CAE7:87501922 (p = 0.0278; 30/6/3): Intronic (1-2) region

```{bash, eval = F, echo = T, class.source="sccCode"}
vcftools --vcf sabWA_UCP1.vcf --hardy --out sabWA_UCP1
less sabWA_UCP1.hwe
```

Nothing significant in the West African sample, but then sample size is only 22, so we most likely don't have the power to detect anything out of HWE.

It would be really great to set up a variant table for the gene (like in 1000 Genomes) so we could see the geographic proportions of variants at specific SNPs, particularly for exonic variants, which look to be relatively small in number. Apparently Ania Jasinska is working on a vervet genome browser right now (would be really helpful for this!).

###Linkage Disequilibrium (Southern Expansion)

First, we will need a list of all loci in our vcf:
```{bash}
zgrep -v "^##" seUCP1.vcf.gz | cut -f1-3 > seUCP1_loci.txt #Get list of variant sites for LD
```

Packages:
```{r}
install.packages("LDheatmap")
install.packages("VariantAnnotation")
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("snpStats", version = "3.8")
#install.packages("snpStats")
```


Analysis:
```{r}
library(Matrix)
library(snpStats)
library(VariantAnnotation)
library(LDheatmap)
library(GenomicFeatures)
library(RMariaDB)

txdb <- makeTxDbFromUCSC(genome="chlSab2", tablename="ensGene") #Create txdb for chlSab2
vcfbig <- readVcf("se_UCP1.vcf.gz", "txdb") #align data with vervet reference genome
ALLmatrix <- genotypeToSnpMatrix(vcfbig)
ALLmatrix

LD <- ld(ALLmatrix$genotypes, depth = 200, stats = "R.squared")
head(LD)
LD
```

Heat Mapper:
```{r}
cols = colorRampPalette(c("yellow", "red"))(10)
image(LD, lwd = 0, cuts= 9, col.regions=cols, colorkey=TRUE)
positions <- c(87478672,87478917,87478957,87479112,87479144,87479170,87479175,87479261,87479344,87479346,87479578,87479598,87479623,87479624,87479700,87479713,87479764,87479791,87479845,87479942,87479962,87480091,87480092,87480247,87480339,87480460,87480482,87480523,87480589,87480601,87481008,87481040,87481098,87481185,87481247,87481250,87481477,87481651,87481817,87481937,87481944,87482171,87482219,87482224,87482246,87482272,87482418,87482499,87482506,87482518,87482566,87482570,87482580,87482583,87482631,87482817,87482830,87482931,87483074,87483454,87483557,87483580,87483627,87483659,87483701,87483703,87483771,87483856,87483906,87483916,87483917,87483956,87483981,87484123,87484131,87484141,87484171,87484184,87484185,87484191,87484196,87484298,87484346,87484403,87484460,87484480,87484515,87484544,87484595,87484667,87484729,87484816,87484818,87484881,87484912,87485006,87485023,87485113,87485123,87485126,87485127,87485145,87485198,87485352,87485425,87485426,87485544,87485572,87485707,87485708,87485782,87485802,87485936,87486002,87486040,87486106,87486129,87486132,87486192,87486232,87486306,87486438,87486540,87486640,87486791,87486856,87486893,87487107,87487212,87487288,87487309,87487379,87487476,87487530,87487531,87487547,87487603,87487637,87487657,87487681,87487774,87487819,87487889,87488011,87488108,87488131,87488141,87488157,87488226,87488227,87488246,87488247,87488284,87488288,87488289,87488308,87488373,87488414,87488473,87488481,87488502,87488513,87488514,87488609,87488755,87488791,87488821,87488890,87488906,87488919,87488983,87489053,87489094,87489127,87489288,87489310,87489380,87489406,87489484,87489516,87489577,87489582,87489651,87489671,87489758,87489780,87489909,87489990,87490020,87490023,87490059,87490209,87490242,87490244,87490304,87490338,87490345,87490432,87490457,87490494,87490563,87490584,87490600,87490669,87490678,87490726,87490750,87490764,87490859,87490876,87490902,87490961,87490964,87491029,87491127,87491132,87491185,87491267,87491318,87491371,87491429,87491434,87491480,87491494,87491534,87491618,87491656,87491684,87491726,87491739,87491796,87491801,87491914,87491946,87491992,87492011,87492020,87492043,87492115,87492132,87492144,87492145,87492201,87492261,87492339,87492384,87492403,87492424,87492537,87492563,87492569,87492579,87492612,87492667,87492739,87492801,87492842,87492898,87492907,87492922,87492949,87492998,87493023,87493031,87493125,87493148,87493153,87493215,87493237,87493263,87493283,87493291,87493379,87493469,87493472,87493519,87493569,87493613,87493664,87493744,87493753,87493830,87493837,87493854,87493882,87493885,87493888,87493967,87493997,87494045,87494126,87494157,87494177,87494188,87494216,87494226,87494338,87494339,87494341,87494342,87494406,87494423,87494503,87494508,87494576,87494632,87494638,87494674,87494842,87494859,87494861,87494916,87495040,87495094,87495117,87495209,87495213,87495244,87495288,87495371,87495400,87495483,87495511,87495557,87495566,87495638,87495673,87495675,87495720,87495756,87495918,87496052,87496059,87496184,87496254,87496359,87496412,87496425,87496460,87496622,87496650,87496753,87496822,87496860,87496865,87496877,87496889,87496897,87496950,87496956,87496971,87497024,87497044,87497047,87497115,87497190,87497200,87497259,87497358,87497419,87497423,87497427,87497467,87497483,87497539,87497546,87497583,87497753,87497809,87497815,87497848,87497910,87497920,87498023,87498068,87498167,87498192,87498326,87498342,87498397,87498450,87498470,87498487,87498501,87498511,87498532,87498564,87498575,87498578,87498611,87498614,87498628,87498633,87498652,87498662,87498678,87498681,87498695,87498769,87498903,87498904,87498981,87499037,87499064,87499099,87499115,87499116,87499128,87499152,87499154,87499168,87499175,87499179,87499180,87499205,87499292,87499295,87499303,87499326,87499356,87499382,87499434,87499439,87499443,87499459,87499485,87499618,87499641,87499761,87499800,87499801,87499818,87499828,87499840,87499854,87499902,87500036,87500045,87500110,87500111,87500152,87500233,87500305,87500306,87500313,87500323,87500325,87500408,87500413,87500454,87500458,87500545,87500558,87500605,87500606,87500611,87500623,87500632,87500650,87500651,87500686,87500780,87500821,87500871,87500927,87500934,87500935,87500951,87500984,87501102,87501183,87501221,87501233,87501339,87501420,87501475,87501486,87501513,87501527,87501535,87501560,87501581,87501599,87501638,87501662,87501699,87501756,87501805,87501834,87501898,87501903,87501904,87501910,87501922,87501946,87501948,87501955,87501974,87501983,87502069,87502083,87502085,87502127,87502141,87502149,87502154,87502235,87502245,87502246,87502255,87502264,87502276,87502281,87502305,87502325,87502347,87502374,87502418,87502422,87502428,87502449,87502469,87502477,87502481,87502522,87502545,87502546,87502551,87502573,87502582,87502594,87502619,87502635,87502808,87502825,87502835,87502857,87502861,87502884,87502929,87502936,87502952,87502973,87502987,87503018,87503019,87503072,87503092,87503134,87503159,87503191,87503236,87503237,87503260,87503318,87503346,87503365,87503369,87503387,87503426,87503444,87503446,87503463,87503470,87503553,87503573,87503604,87503700,87503757,87503770,87503782,87503870,87503880,87503905,87503907,87503952,87503971,87503973,87504003,87504068,87504114,87504115,87504157,87504169,87504220,87504262,87504294,87504295,87504308,87504323,87504352,87504385,87504417,87504421,87504466,87504476,87504558,87504637,87504677,87504718,87504776,87504799,87504850,87504919,87504922,87504930,87504941,87505031,87505032,87505104,87505191,87505214,87505238,87505279,87505287,87505333,87505343,87505368,87505393,87505415,87505469,87505523,87505552,87505553,87505615,87505638,87505646,87505682,87505720,87505737,87505740,87505759,87505825,87505867,87505906,87505945,87505953,87505964,87506003,87506004,87506011,87506019,87506020,87506024,87506090,87506103,87506114,87506123,87506148,87506196,87506197,87506217,87506277,87506319,87506323,87506349,87506382,87506407,87506414,87506433,87506506,87506508,87506541,87506543,87506548,87506571,87506597,87506633,87506974,87507031,87507047,87507048,87507051,87507075,87507082,87507083,87507132,87507140,87507171,87507194,87507221,87507275,87507384,87507385,87507426,87507429,87507430,87507439,87507475,87507478,87507521,87507524,87507536,87507540,87507543,87507549,87507567,87507568,87507589,87507605,87507694,87507706,87507713,87507771,87507830,87507839,87507860,87507871,87507963,87507982,87508091,87508112,87508125,87508130,87508154,87508167,87508195,87508234,87508253,87508268,87508299,87508415,87508426,87508439,87508482,87508500,87508502,87508541,87508626,87508643,87508656,87508745,87508757,87508776,87508823,87508825,87508854,87508869,87508901,87508938,87508974,87509036,87509037,87509041,87509044,87509057,87509058,87509061,87509066,87509085,87509114,87509129,87509222,87509235,87509248,87509258,87509275,87509282,87509311,87509317,87509334,87509439,87509446,87509464,87509500,87509510,87509548,87509553,87509558,87509569,87509586,87509587,87509588,87509608,87509613,87509647,87509686,87509730,87509745,87509754,87509812,87509817,87509842,87509924,87509937,87509950,87509970,87509971,87509975,87509989,87510003,87510035,87510042,87510046,87510051,87510061,87510062,87510067,87510098,87510104,87510125,87510126,87510134,87510165,87510213,87510222,87510279,87510293,87510361,87510399,87510523,87510540,87510598,87510688,87510719,87510725,87510752,87510756,87510793,87510842,87510935,87510973,87511007,87511042,87511043,87511092,87511112,87511116,87511130,87511136,87511189,87511328,87511342,87511434,87511456,87511457,87511493,87511626,87511724,87511777,87511788,87511813,87511817,87511990,87511993,87511999,87512099,87512132,87512265,87512266,87512331,87512381,87512399,87512448,87512452,87512460,87512465,87512470,87512499,87512508,87512515,87512525,87512545,87512588,87512605,87512621)

allheatmapr <- LDheatmap(ALLmatrix$genotypes,
                           genetic.distances=positions,
                           distances="physical",
                           LDmeasure="r",
                           title="Pairwise LD with R^2",
                           add.map=TRUE, add.key=TRUE,
                           geneMapLocation=0.15,
                           SNP.name=c("87493148"),
                           color=NULL, newpage=TRUE,
                           name="ldheatmap")

allheatmapD <- LDheatmap(ALLmatrix$genotype,
                           genetic.distances=positions,
                           distances="physical",
                           LDmeasure="D",
                           title="Pairwise LD with D'",
                           add.map=TRUE, add.key=TRUE,
                           geneMapLocation=0.15,
                           SNP.name=c("87493148"),
                           color=NULL, newpage=TRUE,
                           name=ldheatmap)
View(allheatmapr$LDmatrix)
View(allheatmapD$LDmatrix)
```
Results of the the Linkage analysis are not supper convincing. We ran into trouble mapping the linkage to the vervet reference genome. However the analysis shows a hot spot of linkage on the 5' end of our UCP1 region. Is this an important regulatory region? It does not seem to overlap with exonnic regions of the gene.

### Population Structure (Southern Expansion)

We will begin by making PCA and DAPC plots to show differentiation at the taxonomic level (Cynosuros, Pygerythrus, and Hilgerti) as well as the population level (Cynosuros, Hilgerti, and then the regions Pygerythrus individuals were sampled from: Free State, KwaZulu-Natal, and Eastern Cape). We will also test the significane of the differentiation that these show by performing Adonis and AMOVA on the data.

```{r}
library(vcfR)
library(adegenet)
library(ggplot2)
library(vegan)
library(poppr)
library(dplyr)
```

```{r}
#vervet VCF for UCP1 
UCP1 <- read.vcfR("se_UCP1.vcf.gz", verbose = TRUE)

#creating genind
UCP1_genind <- vcfR2genind(UCP1, sep = "[|/]")

#population data read in 
pop.data <- read.table("Southernexpansion_panel_2.txt", sep = "\t", header = FALSE)
colnames(pop.data) <- c("Sample", "Pop", "Region", "Country", "Taxon", "Population")


#Checking that all the samples in the VCF and the population data frame are the same. Should be TRUE. 

all(colnames(UCP1@gt)[-1] == pop.data$AccessID)

#assigning pop data to genind

pop(UCP1_genind) <- pop.data$Population


#genlight object for PCA

UCP1_genlight <- vcfR2genlight(UCP1)
 
```

#PCA taxon level (Southern Expansion)
```{r}
#assigning populationd data
pop(UCP1_genlight) <- pop.data$Taxon

pca <- glPca(UCP1_genlight, nf = 2)
#Here's a graph of the eigenvalues (or, the principle components). This graph shows how much of the variation of the original dataset is kept with the PCA. This graph was used to determine the number of PCs to keep

barplot(100*pca$eig/sum(pca$eig), col = heat.colors(50), main="PCA Eigenvalues")
title(ylab="Percent of variance\nexplained", line = 2)
title(xlab="Eigenvalues", line = 1)

head(pca, n=6)

#Now, we can graph the results with ggplot!

#Creating a dataframe with pca scores, and assigning population data
pca.scores <- as.data.frame(pca$scores)
pca.scores$pop <- pop(UCP1_genlight)

#ggplot

p <- ggplot(pca.scores, aes(x=PC1, y=PC2, colour=pop)) + geom_point(size=2) + stat_ellipse(level = 0.95, size = 1) + geom_hline(yintercept = 0) + geom_vline(xintercept = 0) + theme_bw()
p

#Ignore the warning error. We see here that there are some outliers in our data. Will the DAPC show the same thing?

#adonis

adonis <- adonis(pca$scores ~ pop, data = pca.scores, method='eu', na.rm = TRUE)
adonis
```

#PCA sub-pop level (Southern Expansion)
```{r}
#assigning populationd data
pop(UCP1_genlight) <- pop.data$Population

pca <- glPca(UCP1_genlight, nf = 2)
#Here's a graph of the eigenvalues (or, the principle components). This graph shows how much of the variation of the original dataset is kept with the PCA. This graph was used to determine the number of PCs to keep

barplot(100*pca$eig/sum(pca$eig), col = heat.colors(50), main="PCA Eigenvalues")
title(ylab="Percent of variance\nexplained", line = 2)
title(xlab="Eigenvalues", line = 1)

head(pca, n=6)

#Now, we can graph the results with ggplot!

#Creating a dataframe with pca scores, and assigning population data
pca.scores <- as.data.frame(pca$scores)
pca.scores$pop <- pop(UCP1_genlight)

#ggplot

p <- ggplot(pca.scores, aes(x=PC1, y=PC2, colour=pop)) + geom_point(size=2) + stat_ellipse(level = 0.95, size = 1) + geom_hline(yintercept = 0) + geom_vline(xintercept = 0) + theme_bw() 
p

#Ignore the warning error. We see here that there are some outliers in our data. Will the DAPC show the same thing?

#adonis

adonis <- adonis(pca$scores ~ pop, data = pca.scores, method='eu', na.rm = TRUE)
adonis
```

#DAPC (Southern Expansion)
```{r}
dapc <- dapc(UCP1_genind, n.pca = 2, n.da = 2)
dapc$grp

#Plotting 
scatter(dapc, cex = 2, legend = TRUE, clabel = F, posi.leg = "bottomleft", scree.pca = TRUE,
        posi.pca = "topleft", cleg = 0.75)
```

We've seen a few things from looking at the PCAs and DAPC from UCP1. With the first graph, we see that C. pygerythrus is separating from C. hilgerti and C. cynosuros mainly along PC1 because of a single cluster of C. pygerythrus. When we look at the sub-populations of each species in a PCA, we see that the cluster of C. pygerythrus that is separating from the other two species is made up of two sub-populations: Free State and KwaZulu-Natal. This clustering significance is also shown by a significant Adonis P-value. In the DAPC however, we see the KwaZulu-Natal and Eastern Cape populations clustering apart from the rest. 

## AMOVA (Southern Expansion)

```{r}
#AMOVA test UCP1 using genlight (because genind assigns 0,1 binary to SNPs that doesnt work with this function)
#remake genlight so we don't have assigned pop data

UCP1_genlight <- vcfR2genlight(UCP1)
UCP1_genlight

#Now to assign strata and match the strata assignments to the individuals in our genlight

strata(UCP1_genlight) <- pop.data[match(indNames(UCP1_genlight), pop.data$Sample), ] 

#now looking at genlight we should see the strata columns we added

UCP1_genlight

#Now the amova with Population

amova1 <- poppr.amova(UCP1_genlight, ~Population, clonecorrect = TRUE)
amova1

#significance testing with randtest 
amova.test <- randtest(amova1) 
plot(amova.test)
amova.test

#Trying now with different strata, taxon

amova2 <- poppr.amova(UCP1_genlight, ~Taxon, clonecorrect = TRUE)
amova2

#significance testing 
amova.test <- randtest(amova2) 
plot(amova.test)
amova.test
```
When we do AMOVA on UCP1 looking at molecular variance between sub-populations, we find that there is significant difference within samples and between populations, but there was no significant difference between samples. When we look at the molecular variance between the three Chlorocebus taxa using AMOVA, we find that there is significant difference within samples, between samples, and between taxa.

## Fst between populations 

We are going to find the fixation index (Fst) pairwise between each population to further support the population differentiation that we found in our DAPC and PCA. We will use the package hierfstat to find the statistic, but first we will use adegenet to assign a population to each sample.

Convert the vcf of UCP1 data into a GENIND object.

```{r}
UCP1vcfR <- read.vcfR("~/Desktop/594_final/se_UCP1.vcf.gz", verbose = TRUE) #Read in data
UCP1_genind <- vcfR2genind(UCP1vcfR, sep = "[|/]") #convert to GENIND
```

Now we have our object, but it doesn't have the population info assigned to each sample. This time, we are breaking up the Free State region's population into north and south. The simplest way to add population parameters to the 'vcf' R file is to run this code on your GENIND object (which has a slot for population information):
```{r}
library(adegenet)
pop(UCP1_genind)<-as.factor(c("cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","FS North","FS North","FS North","FS South","FS South","FS South","FS South","FS South","FS South","FS South","FS South","FS South","FS South","FS South","FS North","FS North","FS North","FS North","FS North","FS North","KZN","KZN","KZN","KZN","KZN","KZN","KZN","KZN","KZN","KZN","KZN","KZN","KZN","KZN","KZN","VSAI3005","FS North","Eastern Cape","Eastern Cape","Eastern Cape","Eastern Cape","Eastern Cape","Eastern Cape","Eastern Cape","Eastern Cape","Eastern Cape","Eastern Cape","Eastern Cape","Eastern Cape","hilgerti","hilgerti","hilgerti","hilgerti","cynosuros","cynosuros","hilgerti","hilgerti"))

fstat(UCP1_genind) # calculating Fst
```

With VSAI3005 included in the  EC pop
```{r}
library(adegenet)
pop(UCP1_genind)<-as.factor(c("cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","cynosuros","FS","FS","FS","FS","FS","FS","FS","FS","FS","FS","FS","FS","FS","FS","FS","FS","FS","FS","FS","FS","KZN","KZN","KZN","KZN","KZN","KZN","KZN","KZN","KZN","KZN","KZN","KZN","KZN","KZN","KZN","Eastern Cape","FS","Eastern Cape","Eastern Cape","Eastern Cape","Eastern Cape","Eastern Cape","Eastern Cape","Eastern Cape","Eastern Cape","Eastern Cape","Eastern Cape","Eastern Cape","Eastern Cape","hilgerti","hilgerti","hilgerti","hilgerti","cynosuros","cynosuros","hilgerti","hilgerti"))
library(hierfstat)
fstat(UCP1_genind) # calculating Fst
```

This gives us Fst all of the populations combined (so that means that about 22% of the variants in UCP1 are not shared between all individuals and about 19% are not shared between populations), but this doesn't tell us which populations are more or less different. Let's look at the pairwise Fst between each population: 
```{r}
UCP1Fst <- pairwise.fst(UCP1_genind[1:73,])
UCP1Fst
```

Now that we have that, we can create a heatmap to visualize it using ggplot2. The output that hierfstat gave us is a "dist" class file, so first we will use reshape2 to make it a matrix. 
```{r}
library(reshape2)
UCP1Fst <- as.matrix(UCP1Fst)
UCP1Fst
colnames(UCP1Fst) <- c("Cynosuros", "Free State", "KwaZulu-Natal", "Eastern Cape", "Hilgerti") #rename columns from numbers to population names. 
rownames(UCP1Fst) <- c("Cynosuros", "Free State", "KwaZulu-Natal", "Eastern Cape", "Hilgerti") #rename rows from numbers to population names. 
UCP1Fst
melted_fst <- melt(UCP1Fst) #melt the data to be used for a heatmap
melted_fst
library(ggplot2)
ggplot(data = melted_fst, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile()
get_lower_tri<-function(UCP1Fst){
    UCP1Fst[lower.tri(UCP1Fst)] <- NA
    return(UCP1Fst)
}

#this looks okay, but we'd rather not have the redundance of the same values being shown twice. So we will just use the lower half of the matrix:

lower_tri <- get_lower_tri(UCP1Fst) #Fill half of the repeated values with "NA's"
lower_tri

melted_UCP1 <- melt(lower_tri, na.rm = TRUE) #melt this half of the matrix
ggplot(data = melted_UCP1, aes(Var2, Var1, fill = value))+
 geom_tile(color = "white")+
 scale_fill_gradient2(low = "white", high = "red", mid = "blue", 
   midpoint = 0, limit = c(0,1), space = "Lab", 
   name="Fst") +
  theme_minimal()+ 
 theme(axis.text.x = element_text(angle = 45, vjust = 1, 
    size = 12, hjust = 1))+
 coord_fixed()
```

Fst matrices and heatmap showing differentiation of UCP1 between Cynosuros, Hilgerti, Free State, Eastern Cape and KwaZulu-Natal populations. Our pairwise Fst matrix and heatmap shows us various levels of differentiation between different populations. For example, Eastern Cape and Kwazulu-Natal populaitons seem to have very few differences in their UCP1 regions, while the Hilgerti and Eastern Cape populations are the most different. This makes sense, considering Eastern Cape and Kwazulu-Natal are geographically close and environmentally similar, while the Hilgerti population samples were collected in Botswana, which is environmentally different from Eastern South Africa. When comparing these results to those of the PCA and DAPC, the latter observation is not extremely prevelant in those population structure figures.

##Signs of selection in *UCP1* (*pygerythrus* only)

Let's take a look for signs of selection at those loci that are out of HWE in the *pygerythrus* sample.

We'll use the following packages in *R*:
```{r, eval = F, echo = T}
library(vcfR)
library(PopGenome)
library(pegas)
```

First, to run some of these analyses, the unzipped version of the VCF file needs to be in a folder or subdirectory to be read, so make sure it's in one using the following code:

```{bash, eval = F, echo = T, class.source="sccCode"}
mkdir pygUCP1
cp pygUCP1.vcf pygUCP1/pygUCP1.vcf
```

Here we'll make our *GENOME* object:
```{r, eval = F, echo = T}
pygUCP1.genome <- readData("pygUCP1", format = "VCF")
pygUCP1.genome
```

And here we'll make our *DNAbin* object:
```{r, eval = F, echo = T}
pyg <- read.vcfR("pygUCP1/pygUCP1.vcf")
pygUCP1.dna <- vcfR2DNAbin(pyg)
pygUCP1.dna
```

### Fu and Li's D and F

The function `neutrality.stats` from *PopGenome* conveniently calculates several different neutrality statistics for a given population. We'll use it now to calculate Fu and Li's D and F: 

```{r, eval = F, echo = T}
neut <- neutrality.stats(pygUCP1.genome)
get.neutrality(neut)

#To see results: 

neut@Fu.Li.F #1.983563
neut@Fu.Li.D #1.91637
```

These are both positive, suggesting overall an excess of old/ancestral variants in this region. Variants that are present are carried by a lot of individuals.

### Tajima's D

When we ran the `neutrality.stats` function in *PopGenome*, it also calcuated our Tajima's D statistic. We can *preview* our Tajima's D results from the *PopGenome* output... 
```{r, eval = F, echo = T}
neut@Tajima.D #1.305863
```

##And now on the Southern Expansion:

First, we will look at Tajima's D. This tests whether mutations in the UCP1 region in a population are following or violating the assumptions of neutrality models. If they are not, this implies selection is acting on them. When D is close to zero, there are no alleles over or under represented, meaning they are neutral. If D is negative, this implies purifying selection, while if D is positive, the population is experiencing positive selection on the region. 

To do this in R, we will use the tajima function in the pegas package.
```{r}
library(pegas)
library(vcfR)
```

First, we will do it for our Cynosuros individuals: 
```{r}
UCP1cyn <- read.vcfR("~/Desktop/594_final/cyn_UCP1.vcf.gz", verbose = TRUE) #read in data
UCP1dna <- vcfR2DNAbin(UCP1cyn) #create DNAbin object to be used by pegas
UCP1dna
tajima1 <- tajima.test(UCP1dna)
tajima1
```
Tajima's D for UCP1 is strongly negative, meaning that there is selection against it
Then for Pygerythrus:
```{r}
UCP1 <- read.vcfR("~/Desktop/594_final/pyg_UCP1.vcf.gz", verbose = TRUE)
UCP1dna <- vcfR2DNAbin(UCP1)
UCP1dna
tajima1 <- tajima.test(UCP1dna)
tajima1
```

Using vcftools: 
```{bash}
# Cynosuros
#UCP1
vcftools --gzvcf cyn_UCP1.vcf.gz --TajimaD 500 # We chose 500 as the window size 
mv out.Tajima.D cynUCP1.Tajima.D #rename the output file 
mv out.log cynUCP1TD.log #rename log file 

# Pygerythrus
#UCP1
vcftools --gzvcf pyg_UCP1.vcf.gz --TajimaD 500 # We chose 500 as the window size 
mv out.Tajima.D pygUCP1.Tajima.D #rename the output file 
mv out.log pygUCP1TD.log #rename log file 
```

FU and Li's D and F statistic are a little similar in that anything deviating from 0 is a violation of neutrality. The D statistic is based on the difference between the number of private mutations in the sample and the total number of mutations. The F statistic is based on the difference between private mutations and average number of nucleotide differences between sequence pairs. 

Packages:
```{r}
library(vcfR)
library(PopGenome)
```

Pygerythrus
```{r}
UCP1 <- read.vcfR("~/Desktop/final/pyg_UCP1.vcf.gz", verbose = TRUE)
UCP1dna <- vcfR2DNAbin(UCP1)
UCP1dna
tajima <- tajima.test(UCP1dna)
tajima
```

Cynosuros
```{r}
UCP1 <- read.vcfR("~/Desktop/final/cyn_UCP1.vcf.gz", verbose = TRUE)
UCP1dna <- vcfR2DNAbin(UCP1)
UCP1dna
tajima <- tajima.test(UCP1dna)
tajima
```
With these values, we see that the Southern Expansion as one large population is close to neutrality: none of the statistics are strongly positive. However, Fu and Li's D and F are strongly positive in both the Cynosuros and Pygerythrus. This means that there is an excess of old variants in the population, and very few uniqu variants, implying that selection likely occurred for these ancestral variants in the past. The reason we do not see this in the whole Southern Expansion analysis is most likely because we have a third taxa (Hilgerti) included. As for Tajima's D, Pygerythrus shows strong signs of positive or balancing selection. Cynosuros and the Southern Expansion populations also show this, but not nearly as strong.

##More Statistics
This time we are using PopGenome to see if we tget the same numbers and to calculate Fu Li's D and F for a different perpective.
Packages:
```{r}
install.packages("PopGenome")

library(vcfR)
library(PopGenome)
library(pegas)


```

```{bash}
mkdir UCP1
cp se_UCP1.vcf UCP1/se_UCP1.vcf
```


Analysis:
```{r}
# Load SE UCP1 data
UCP1genome <- readData("UCP1", format="VCF")
UCP1genome
neut <- neutrality.stats(UCP1genome)
get.neutrality(neut)
neut@Fu.Li.F
neut@Fu.Li.D
neut@Tajima.D

# Load CYN UCP1 data
UCP1genome <- readData("cyn_UCP1", format="VCF")
UCP1genome
neut <- neutrality.stats(UCP1genome)
get.neutrality(neut)
neut@Fu.Li.F
neut@Fu.Li.D
neut@Tajima.D

# Load PYG UCP1 data
UCP1genome <- readData("pyg_UCP1", format="VCF")
UCP1genome
neut <- neutrality.stats(UCP1genome)
get.neutrality(neut)
neut@Fu.Li.F
neut@Fu.Li.D
neut@Tajima.D

UCP1genome <- readData("UCP1", format="VCF")
UCP1genome
neut <- neutrality.stats(UCP1genome)
get.neutrality(neut)
neut@Fu.Li.F
neut@Fu.Li.D
neut@Tajima.D
```

Results for vcfR, Pegas and Popgenome are all in accordance. Cool! We can feel confident about our results.
How would you interpret these results?

But, we can get more useful information by using the `tajima.test` function in the *pegas* package. This function will use the *DNAbin* object that we created earlier as an input. It will not only give us the same D statistic as was calculated by the `neutrality.stats` function, which is all well and good, but will also give us a *P-value* associated with our test. This is important, because it will give us a sense of how significant the results are of our neutrality test. 
<br>
```{r, eval = F, echo = T}
tajima <- tajima.test(pygUCP1.dna)
tajima
```

Ok, so it looks like the results for Tajima's D is not significant:

D = 1.305863, p = 0.1915991

##Selective Sweep Analysis in Vervets

First, we'll load our necessary modules:
```{r,eval=F,echo=T, class.source="sccCode"}
module load tabix
module load vcftools
module load python
```

###Estimating the Ancestral Alleles for Your Gene Region [CHRISTIAN]

Now, before we can move forward with this, we need to figure out what the ancestral allele is for each of our SNPs. We'll do this with a program called *est-sfs*, first published here:

[Keightley, P. D., Campos, J. L., Booker T. R. and Charlesworth, B. (2016). Inferring the frequency spectrum of derived variants to quantify adaptive molecular evolution in protein-coding genes of Drosophila melanogaster. Genetics 203: 975-984.](http://www.genetics.org/content/209/3/897)

So for this analysis, we need our outgroups to be nested with the vervets at the bottom, Outgroup 1 a sister to vervets, and Outgroup 2 a sister to the LCA of vervets and Outgroup 1. If we have an Outgroup 3 (which is the maximum), it has to be a sister to the LCA of Outgroup 2 and the LCA of Outgroup1/Vervets. This means we can't have multiple sister taxa (like two species of *Macaca*) in this analysis. For simplicity sake, we're using the *Macaca mulatta* reference genome as our outgroup, which is available for alignment in the UCSC Genome Browser.

[This step is not necassary]
Now, once this is chosen, there are few steps that need to be taken...

To start, it looks like we'll need to make an alignment from our VCF file with the population sample... to do that, we can perhaps use [this unproven but seeminly perfect command written by Stephan Kamrad](https://github.com/Bahler-Lab/alignment-from-vcf). This will require 1) the vervet reference in FASTA format (it's in the '*hilgerti*' drive in the folder '*vervetRef_ChlSab1_1*'), 2) the VCF file, gzipped and indexed, 3) the name of the contig in the vervet reference containing the region of interest (it's '*AQIB01017419.1*', I found this by searching the position on *Ensembl*; note that in the VCF file the contig is called CAE7, which is just chromosome 7), 4) start of the region (87482195), 5) end of the region (87512665), 6) ploidy (it's diploid), and 7) path to the output file, which will also be in FASTA format.

[NEEDS TO BE FINISHED]

OK! LOTS of things happening in Excel... but we got the final data file to run the ancestral allele estimation program, currently in the `est-sfs-release-2.03` folder, called *vervet_mac_allelefreq.txt*. Here is a description of how we did this.

First we use bcftools to extract the information we need from our population vcf file. We need the chromosome, position, reference allele, alternate allele, and genotypes for each individual in our sample which can be achieved using the code below.
```{bash}
module load bcftools

bcftools query -f '%CHROM\t%POS\t%REF\t%ALT[\t%SAMPLE=%GT]\n' se_UCP1.vcf.gz -o se_UCP1_bcftoolsoutput.txt
```

Next, open the file in excel so we can do some data processing. Once the data is in excel and the columns line up properly, use the find and replace function to remove the info we do not need from the genotype columns so they show only the binary genotype codes (e.g. 1|0 or 1|1 or 0|1 or 0|0). Create 4 new column where we will calculate the genotype frequencies. for example to find the number of individuals with the genotype 0|0 at a the first position in your vcf enter this formula in the appropriate cell: =COUNTIF(E2:BY2,"0|0"). Once the number for each genotype for all positions have been calculated we can then calculate how many reference alleles and alternate alleles are present in our population using these formulas respectively: totalREF "=2*CA2+CB2+CC2" , totalALT "=2*CD2+CC2+CB2". 
Keep in mind you may need to adjust column and rows to fit your dataset, which is true for most of the formulas in this tutorial. 

Next we use the Reference and alternate alleles from the vcf to infer the exact number of A,C,G, and T alleles at each position in new columns using the formula: =IF(C2="A",CE2,IF(D2="A",CF2,0)). Do the same for C, G, and T in new columns. Now we can determine what the major alleles is for each position by simply assigning which ever base is most frequent. for example if you have A=0 C=115, G=0, T=31, we would say that Cis the major allele. In cases where you have an equal number of different alleles, we consider the reference allele to be major.

Next we must create an alignment of our region of interest using the vervet reference genome and the macaque reference genome. In order to do this we obtained the regions from emsembl online genome database using our coordinates. Then we align the sequences using MAFFT which can be done using command line or via the online tool at: *https://mafft.cbrc.jp/alignment/server/index.html*

Import the aligned sequences into a new tab in your excel file. On another new tab we will then need to isolate from the macaque alignment only the positions in our vcf files using this formula: =VLOOKUP(A2,'mac1'!A:B,2,FALSE). Then we need to get our data in to the proper format (A,C,G,T) for est-sfs using this formula for each of the 4 possible bases at each position in the order listed above: =COUNTIF(B2,"A")

Lastly, we compile the allele counts from both our population and the macaque reference into a single text document which should look like this:

A	C	G	T		A	C	G	T
146	0	0	0		1	0	0	0
0	5	0	141		0	0	0	1
145	0	1	0		1	0	0	0
146	0	0	0		1	0	0	0
2	0	144	0		0	0	1	0
0	115	0	31		0	1	0	0
0	146	0	0		0	1	0	0
146	0	0	0		1	0	0	0
115	31	0	0		1	0	0	0
0	5	0	141		0	0	0	1
0	0	0	146		0	1	0	0
0	0	146	0		0	0	1	0
1	0	145	0		0	0	1	0
0	146	0	0		0	1	0	0
131	15	0	0		1	0	0	0
0	1	0	145		0	0	0	1
0	114	0	32		0	0	0	1
51	0	95	0		0	0	1	0

This is the file in `est-sfs-release-2.03` folder, called *vervet_mac_allelefreq.txt*.

To run the ancestral allele estimation program, you just run the following code:
```{bash, eval=F,class.scource="sccCode"}
cd /Desktop/est-sfs-release-2.03 #make sure you're in the est-sfs folder with executable and all necessary files
```

And voila!  It runs in a few seconds. Very anti-climactic... But worth it. Now the *output_file_pval.txt* gives you the positions in numerical order (albeit with a different numbering system starting at 1) with a p-value indicating like likelihood (as a percent) that the major allele in our population sample is the ancestral allele. Most are 100%, which is nice and easy. Those that are less than 50% likely to be the major allele, we will then assume that the ancestral allele is the one in *Macaca*. Those for which there are two major alleles (balanced polymorphisms; there are a few), we'll choose the vervet reference allele as ancestral. Those for whom we don't have an allele for *Macaca* (in the ZA population there are 3, which we had to exclude the positions of to run est-sfs, and now we have to reinsert them into our final file so that the AA file matches up with the VCF!), we'll also then use the vervet reference allele as ancestral.

###Preparing Haplotype and Map Files for iHS

This code is to create the two inputs needed for iHS analysis in the {rehh} package:

Let's impute the *pygerythrus* dataset:
```{r,eval=F,echo=T, class.source="sccCode"}
vcftools --gzvcf pygUCP1.vcf.gz --IMPUTE
```

Now, we need to pull out the reference and alternative allele for each site:
```{r,eval=F,echo=T, class.source="sccCode"}
module load bcftools
bcftools query -f'[%POS %REF %ALT\n]' pygUCP1.vcf.gz > outREFALT.INFO
```

Now you must create a very specifically formatted file that includes our Ancestral Allele estimates and the information we just pulled using our {bcftools} command above. For an example, see the `Documents/VervetAA/UCP1_AA_mod.txt`. Import these two files into Excel and make them match this format (you'll need to use the VLOOKUP command to reference positions in pulling in data, and add the three 'pipes' to the end of the AA data cell entries using the '&' operator). The final output you make is a file called 'UCP1_AA_mod' (this MUST be made using a text editor with no richtext, or that can make just a UNIX file, like AlphaX or Atom... otherwise the formatting of the .txt or .rtf will mess things up).

Ok, now we need to modify these files so that they fit into the workflow for creating the haplotype and mapping files for {rehh}:
```{r,eval=F,echo=T, class.source="sccCode"}
more +2 UCP1_AA_mod | awk '{if($3==$5) print$0,"yes";if($3!=$5) print$0,"no";}' | sed -e 's/\t/ /g' > out3.INFO

join -j 2 -o 1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8 out3.INFO <(sort -k2 out.impute.legend) > out4.INFO

paste out4.INFO out.impute.hap | awk '($5!="." && $5!="N" && $5!="-")' > merged.out

awk '{for(i=7;i<=NF;i++)if($i==0)$i=3; else $i=4; print}' merged.out | awk '{if(ip[$2]=="") print; ip [$2]=1}' > merged2.out

awk '{print $1"-"$2,$1,$2,"1","2"}' merged2.out > map_pygUCP1.out

sed -e '/yes/ s/3/1/g' -e '/yes/ s/4/2/g' -e '/no/ s/3/2/g' -e '/no/ s/4/1/g' merged2.out | cut -d " " -f7-  > merged3.out

python -c "import sys; print('\n'.join(' '.join(c) for c in zip(*(l.split() for l in sys.stdin.readlines() if l.strip()))))" < merged3.out > merged4.out

awk '{print NR " "$0}' merged4.out > hap_pygUCP1.out
```

OK... here goes!

```{r,eval=F,echo=T, class.source="sccCode"}
module load R
module load rstudio
rstudio &
```

```{r, eval = F, echo = T}
library(rehh)
hap<-data2haplohh(hap_file="/Users/christiangagnon/Documents/pyg_ihs/hap_pygUCP1.out",map_file="/Users/christiangagnon/Documents/pyg_ihs/map_pygUCP1.out", allele_coding = "map")
#change chromosome name:
hap@chr.name<-"7"
```

It worked! Our dataset consists of 866 SNPs split into 98 haplotypes. Let's try this...

```{r,eval = F, echo = T}
ehh<-scan_hh(hap,limhaplo=2,limehh=0.5,limehhs=0.5,maxgap=NA,threads=1)
```

Retrieve our iHS scores:
```{r,eval = F, echo = T}
ihs <- ihh2ihs(ehh,freqbin=0.1)
```

And plot them:
```{r,eval = F, echo = T}
#First we need to change the chromosome name to just '7':
#ihs$iHS$CHR<-as.vector(rep(7,108))
#ihsplot(ihs, plot.pval=TRUE, ylim.scan=2.5, pch=16, main="iHS")
cr.pyg <- calc_candidate_regions(ihs,
                                 threshold = 1.3,
                                 pval = TRUE,
                                 window_size = 1,
                                 overlap = 0.9,
                                 min_n_extr_mrk = 2)
palette(c("red", "green"))
manhattanplot(ihs, pval = TRUE, threshold = 1.3, main = "iHS (Chlorocebus pygerethrus)", cr = cr.pyg)
```

```{r,eval = F, echo = T}
manhattanplot(ihs, pval = TRUE, threshold = 1.3, main = "iHS (Chlorocebus pygerethrus)")
```

```{r,eval = F, echo = T}
ihs_pyg <- ihs$ihs
ihs_pyg.qqman <- data.frame(
    CHR = as.integer(factor(ihs_pyg$CHR, 
                            levels = unique(ihs_pyg$CHR))),
                               # chromosomes as integers
    BP = ihs_pyg$POSITION,         # base pairs
    P = 10**(-ihs_pyg$LOGPVALUE),  # transform back to p-values
    SNP = row.names(ihs_pyg)       # SNP names
    )
library(qqman)
manhattan(ihs_pyg.qqman,
          col = c("red","green"),
          suggestiveline = 1.3,
          ylim =c(0,4),
          xlim =c(87478000,87514000),
          annotatePval = 0.0001)
```

Ok, this looks promising.  No huge hits, but then we wouldn't expect that with this sample size anyway... looks like two potential regions, with the most promising being the one around 87,492,000... where we do have two SNPs out of HWE! That's great!

Let's actually check the p-values:
```{r,eval = F, echo = T}
ihs$ihs
```

Significant hits include (p value is in -log<sub>10</sub>, meaning 1.3 is the 0.05 threshold):
* CAE7-87483771, p<sub>iHS</sub> = 1.306587579 (HWE)  mrk 67
* CAE7-87493023, p<sub>iHS</sub> = 2.243397914 (HWE)  mrk 263
* CAE7-87493291, p<sub>iHS</sub> = 1.752922068        mrk 272
* CAE7-87493379, p<sub>iHS</sub> = 1.752922068        mrk 273
* CAE7-87494157, p<sub>iHS</sub> = 1.448765672        mrk 292
* CAE7-87496971, p<sub>iHS</sub> = 1.698050226 (HWE)* mrk 351
* CAE7-87501948, p<sub>iHS</sub> = 2.122255742*       mrk 496
* CAE7-87502235, p<sub>iHS</sub> = 1.336851559        mrk 507
* CAE7-87506414, p<sub>iHS</sub> = 2.290787752        mrk 659
* CAE7-87509248, p<sub>iHS</sub> = 2.173679930        mrk 755

CAE7-87502305	7	87502305	2.187539403	1.542070137     mrk 514
CAE7-87505287	7	87505287	2.084613893	1.430575027     mrk 615

Many of these other hits are *not* out of HWE, suggesting what?  Is the selective sweep older than the South African population?

Let's run some SNP analyses with those that are out of HWE. Remember, for these we'll need the number count for each position in order (e.g., first position in the list is mrk=1, second is mrk=2, and so on):

* CAE7:87483454 (p = 0.0437; 15/17/17): 3' downstream (60)

```{r,eval = F, echo = T}
res.ehh<-calc_ehh(hap,mrk=67)
plot(res.ehh)
```

```{r,eval = F, echo = T}
furcation <- calc_furcation(hap, mrk = 67)
plot(furcation)
```

```{r,eval = F, echo = T}
res.ehh<-calc_ehh(hap,mrk=263)
plot(res.ehh)
```
```{r,eval = F, echo = T}
furcation <- calc_furcation(hap, mrk = 263)
plot(furcation)
```
```{r,eval = F, echo = T}
res.ehh<-calc_ehh(hap,mrk=351)
plot(res.ehh)
```

```{r,eval = F, echo = T}
furcation <- calc_furcation(hap, , mrk = 351)
plot(furcation)
```
Some markers look better than others (e.g., marker 60 here looks definitely NOT under a selective sweep; exported as PNG at 700x700). We can take a further look at this one using the bifurcation plot:
```{r,eval = F, echo = T}
#layout(matrix(1:2,2,1))
#bifurcation.diagram(hap,mrk_foc=67,all_foc=1,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87483454\n(Ancestral Allele)")
#bifurcation.diagram(hap,mrk_foc=67,all_foc=2,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87483454\n(Derived Allele)")
```

So I had to toggle down the lower limit of the haplotype count the figure would allow (`limhapcount` default is 10, reduced here to 2) because there are so few individuals with the ancestral allele at this locus. I suspect this will be the same for most loci. Again, this could be a problem of the ancestral allele being estimated poorly, or it could represent a large shift away from the ancestral state. It all hinges on how confident we are in our ancestral allele estimations (figure exported as PNG at 700x850).

* CAE7:87483771 (p = 0.0437; 15/17/17): 3' downstream (67)

```{r,eval = F, echo = T}
res.ehh<-calc_ehh(hap,mrk=67,main="EHH at CAE7:87483771")
```

```{r,eval = F, echo = T}
layout(matrix(1:2,2,1))
bifurcation.diagram(hap,mrk_foc=67,all_foc=1,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87483771\n(Ancestral Allele)")
bifurcation.diagram(hap,mrk_foc=67,all_foc=2,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87483771\n(Derived Allele)")
```

* CAE7:87483956	(p = 0.0218; 43/4/2): 3' downstream (72)

```{r,eval = F, echo = T}
res.ehh<-calc_ehh(hap,mrk=72,main="EHH at CAE7:87483956")
```

```{r,eval = F, echo = T}
layout(matrix(1:2,2,1))
bifurcation.diagram(hap,mrk_foc=72,all_foc=1,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87483956\n(Ancestral Allele)")
bifurcation.diagram(hap,mrk_foc=72,all_foc=2,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87483956\n(Derived Allele)")
```

YESSS!  This one looks good!!!

* CAE7:87492384 (p = 0.0062; 31/11/7): This is in the 3' UTR region (246)

```{r,eval = F, echo = T}
res.ehh<-calc_ehh(hap,mrk=246,main="EHH at CAE7:87492384")
```

```{r,eval = F, echo = T}
layout(matrix(1:2,2,1))
bifurcation.diagram(hap,mrk_foc=246,all_foc=1,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87492384\n(Ancestral Allele)")
bifurcation.diagram(hap,mrk_foc=246,all_foc=2,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87492384\n(Derived Allele)")
```

YESS!  Also looks good!!!

* CAE7:87492801 (p = 0.0437; 15/17/17): Intronic (5-6) variant (256)

```{r,eval = F, echo = T}
res.ehh<-calc_ehh(hap,mrk=256,main="EHH at CAE7:87492801")
```

```{r,eval = F, echo = T}
layout(matrix(1:2,2,1))
bifurcation.diagram(hap,mrk_foc=256,all_foc=1,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87492801\n(Ancestral Allele)")
bifurcation.diagram(hap,mrk_foc=256,all_foc=2,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87492801\n(Derived Allele)")
```

Meh... nope.

* CAE7:87492842 (p = 0.0166; 30/12/7): Intronic (5-6) variant (257)

```{r,eval = F, echo = T}
res.ehh<-calc_ehh(hap,mrk=257,main="EHH at CAE7:87492842")
```

```{r,eval = F, echo = T}
layout(matrix(1:2,2,1))
bifurcation.diagram(hap,mrk_foc=257,all_foc=1,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87492842\n(Ancestral Allele)")
bifurcation.diagram(hap,mrk_foc=257,all_foc=2,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87492842\n(Derived Allele)")
```

Looks ok... a bit ambiguous, but appears to be selection?

* CAE7:87493023 (p = 0.0436; 17/17/15): Intronic (5-6) variant (263)

```{r,eval = F, echo = T}
res.ehh<-calc_ehh(hap,mrk=263,main="EHH at CAE7:87493023")
```

```{r,eval = F, echo = T}
layout(matrix(1:2,2,1))
bifurcation.diagram(hap,mrk_foc=263,all_foc=1,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87493023\n(Ancestral Allele)")
bifurcation.diagram(hap,mrk_foc=263,all_foc=2,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87493023\n(Derived Allele)")
```

WOW!  Yes to a strong selective sweep here!

* CAE7:87496971 (p = 0.0090; 19/15/15): Intronic (2-3) variant (351)

```{r,eval = F, echo = T}
res.ehh<-calc_ehh(hap,mrk=351,main="EHH at CAE7:87496971")
```

```{r,eval = F, echo = T}
layout(matrix(1:2,2,1))
bifurcation.diagram(hap,mrk_foc=351,all_foc=1,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87496971\n(Ancestral Allele)")
bifurcation.diagram(hap,mrk_foc=351,all_foc=2,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87496971\n(Derived Allele)")
```

No selection here.

* CAE7:87497024 (p = 0.0438; 32/12/5): Intronic (2-3) variant (352)

```{r,eval = F, echo = T}
res.ehh<-calc_ehh(hap,mrk=352,main="EHH at CAE7:87497024")
```

```{r,eval = F, echo = T}
layout(matrix(1:2,2,1))
bifurcation.diagram(hap,mrk_foc=352,all_foc=1,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87497024\n(Ancestral Allele)")
bifurcation.diagram(hap,mrk_foc=352,all_foc=2,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87497024\n(Derived Allele)")
```

Looks potentially good as a selective sweep!

* CAE7:87497539	(p = 0.0615; 46/2/1: Intronic (2-3) variant (365)

```{r,eval = F, echo = T}
res.ehh<-calc_ehh(hap,mrk=365,main="EHH at CAE7:87497539")
```

```{r,eval = F, echo = T}
layout(matrix(1:2,2,1))
bifurcation.diagram(hap,mrk_foc=365,all_foc=1,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87497539\n(Ancestral Allele)")
bifurcation.diagram(hap,mrk_foc=365,all_foc=2,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87497539\n(Derived Allele)")
```

* CAE7:87497809 (p = 0.0207; 18/16/15): Intronic (2-3) variant (369)

```{r,eval = F, echo = T}
res.ehh<-calc_ehh(hap,mrk=369,main="EHH at CAE7:87497809")
```

```{r,eval = F, echo = T}
layout(matrix(1:2,2,1))
bifurcation.diagram(hap,mrk_foc=369,all_foc=1,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87497809\n(Ancestral Allele)")
bifurcation.diagram(hap,mrk_foc=369,all_foc=2,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87497809\n(Derived Allele)")
```

Not really...

* CAE7:87497815 (p = 0.0437; 15/17/17): Intronic (2-3) variant (370)

```{r,eval = F, echo = T}
res.ehh<-calc_ehh(hap,mrk=370,main="EHH at CAE7:87497815")
```

```{r,eval = F, echo = T}
layout(matrix(1:2,2,1))
bifurcation.diagram(hap,mrk_foc=370,all_foc=1,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87497815\n(Ancestral Allele)")
bifurcation.diagram(hap,mrk_foc=370,all_foc=2,nmrk_l=30,nmrk_r=30,limhapcount=2,linecol="darkgreen",main="Bifurcation diagram CAE7:87497815\n(Derived Allele)")
```

Looks pretty good as a selective sweep!

##SNP-based Whole Genome Phylogeny of Vervets

So to get the phylogeny we'll use for the regressions, we'll used a SNP-based phylogeny from the Svardal et al. VCF dataset. In this case, the easiest route may be to analyze the VCF file using the pipeline from [SNPhylo](https://bmcgenomics.biomedcentral.com/articles/10.1186/1471-2164-15-162), which is available in the *SCC*.

Now first, we need to change the chromosome numbers in the VCF file (to erase the `CAE` prefix before the number itself). This is relatively easy once you've navigated to the folder containing the VCF file (here renamed *allvervets.vcf*:
```{r,eval=F,echo=T, class.source="sccCode"}
awk '{gsub(/^CAE/,""); print}' allvervets.vcf > allvervets_nocae.vcf
```

Now, we need to run this analysis as a batch file (it takes up A LOT of memory, and consistently crashes even on the SMGAL deskstop computers).  To do this, I've written a script, called `vervet_phylo1.sp` that we'll load to run a batch using the following code:

```{r,eval=F,echo=T, class.source="sccCode"}
qsub vervet_phylo1.sp
```

Ok... after much trial and tribulation (the whole SNPhylo pipeline is a bust, we get some useful outputs), we have a FASTA alignment from {SNPRelate}... let's import it and construct a tree using {phangorn} and {ape}:
```{r,eval=F,echo=T}
setwd("~/Desktop/vervAN333/snphylo")
library(ape)
library(phangorn)
library(phytools)
library(geiger)
#Here we load in the fasta file output from SNPRelate:
vervets <- read.dna("vervet_phylo1.fasta", format="fasta")
#Here we convert it to phangorn format:
vervets_phyDat <- phyDat(vervets, type = "DNA", levels = NULL)
#Here we construct out distance matrix using a Jukes-Cantor mutation model:
dnadist<-dist.ml(vervets_phyDat,model="JC69")
#Here we construct a basic NJ tree and take a look at it:
vervets_NJ<-NJ(dnadist)
plot(vervets_NJ,main="Vervets NJ Tree")
```

Now, there are a couple ways to contruct a statistically valid ML tree from our data.  There's the *slow* way using {phangorn}:

```{r,eval=F,echo=T}
#Here we construct a ML tree from our data:
fit<-pml(vervets_NJ,vervets_phyDat)
#And here we optimize tree topology based on the JC mutation model:
fitJC<-optim.pml(fit, model = "JC", rearrangement = "stochastic")
logLik(fitJC)
#Let's bootstrap this:
bs<-bootstrap.pml(fitJC,bs=100,optNni=TRUE,multicore=TRUE,control=pml.control(trace=0))
#And plot it:
plotBS(midpoint(fitJC$tree),bs,p=50,type="p")
#And let's export this in Newick format so we can make a pretty figure in FigTree:
write.tree(bs,file="vervet_bootstrap.tre")
```

And a *fast* way using `raxml` in the {ips} package (haven't yet validated this as I don't have `raxml` on my laptop):

```{r,eval=F,echo=T}
library(ips)
vervetrax<-read.dna("vervet_phylo1.fasta",format="fasta",as.matrix=TRUE)
vervet.rax.jc<-raxml(dnadist,
m="GTRGAMMAIX", # model
f="a", # best tree and bootstrap
p=1234, # random number seed
x=2345, # random seed for rapid bootstrapping
N=500, # number of bootstrap replicates
file="vervet1", # name of output files
exec="raxmlHPC-PTHREADS-SSE3", # name of executable, this means that RAXML must be downloaded and available, and the pathway must be listed here!
threads=1
)
```

Now, this tree is for ALL the vervets. To run our models only in the South African vervets (since that's where we're at for the ASP poster), we'll need to either 1) prune this tree down to just those animals represented in our analysis, or 2) rerun the above analysis with just the SA vervet sequences preserved in the FASTA file.

Let's drop everything but the SA monkeys we have genomic data for. To do this, we need to create a vector of the tips we'd like to prune.

To start, let's import the `vervet.population.panel` as a dataframe so we can easily maneuver around:
```{r,eval=F,echo=T}
verv.panel<-read.table("vervet.population.panel",header=T,sep="\t")
summary(verv.panel)
```

Now let's use {dplyr} to get lists of individuals to prune from the tree so that we can run an analysis on just the southern expansion, and just South Africa:
```{r,eval=F,echo=T}
library(dplyr)
vervpop<-tbl_df(verv.panel)
nonpyg<-vervpop %>%
  filter(country != "South Africa") %>%
  select(sample) %>%
  droplevels()
nonpyg<-nonpyg$sample

nonsouthern<-vervpop %>%
  filter(taxon != "pygerythrus") %>%
  filter(taxon != "cynosuros") %>%
  filter(taxon != "hilgerti") %>%
  select(sample) %>%
  droplevels()
nonsouthern<-nonsouthern$sample
```

Now let's import our tree block and 'best' tree:
```{r,eval=F,echo=T}
vervtree<-read.tree("vervet_bootstrap.tre")
vervtree1<-fitJC$tree
vervtree1<-as.phylo(vervtree1)
write.tree(vervtree1,"vervtree1.tre")
```

And find our unwanted tips and drop them:
```{r,eval=F,echo=T}
ii<-sapply(nonpyg,grep,vervtree1$tip.label)
nonpyg<-vervtree1$tip.label[ii]
vervet.sa<-drop.tip(vervtree1,nonpyg)
plot(vervet.sa)
```

And let's not forget to root our tree at the right place to indicate where the ancestral node was before we pruned:
```{r,eval=F,echo=T}
#let's see where the nodes are:
plotTree(vervet.sa,node.numbers=TRUE)
#Ok, let's root it at node 50
vervet.sa<-root(vervet.sa,node=50)
plot(vervet.sa)
```

We can do this for the whole tree block, as well:
```{r,eval=F,echo=T}
vervet.sa.block<-lapply(vervtree,drop.tip,tip=nonpyg)
class(vervet.sa.block)<-"multiPhylo"
```

Let's do this for the southern block, too:
```{r,eval=F,echo=T}
iii<-sapply(nonsouthern,grep,vervtree1$tip.label)
nonsouthern<-vervtree1$tip.label[iii]
vervet.southern<-drop.tip(vervtree1,nonsouthern)
plot(vervet.southern)

vervet.southern.block<-lapply(vervtree,drop.tip,tip=nonsouthern)
class(vervet.southern.block)<-"multiPhylo"

#let's see where the nodes are:
plotTree(vervet.southern,node.numbers=TRUE)
#Ok, let's root it at node 74
vervet.southern<-root(vervet.southern,node=74)
plot(vervet.southern)
```

Ok, now we've got our full trees ready! The multiple trees constructed for our blocks will allow us to incorporate phylogenetic uncertainty into our analysis, as well (which is a good thing)!

Now one more thing... we may need to just do this by population... if that's the case, we can simply cut the tree down to representative individuals in each cluster and use them to get a geographic hit in our database so that we can link climate to them.  Here are the population level trees for South Africa, with the populations in South Africa divided into Free State North (Sandveld, Soetdoring, Parys; represented by VSAC1015), Free State South (Gariep; represented by VSAB2012), Eastern Cape (represented by VSAL3005), and KwaZulu-Natal (represented by VSAF1015).

```{r,eval=F,echo=T}
keep<-c("VSAC1015","VSAB2012","VSAL3005","VSAF1015")
region.tree<-drop.tip(vervtree1,vervtree1$tip.label[-match(keep, vervtree1$tip.label)])
plot(region.tree)
region.tree$tip.label[region.tree$tip.label=="VSAC1015"] <- "FS North"
region.tree$tip.label[region.tree$tip.label=="VSAB2012"] <- "FS South"
region.tree$tip.label[region.tree$tip.label=="VSAL3005"] <- "Eastern Cape"
region.tree$tip.label[region.tree$tip.label=="VSAF1015"] <- "KwaZulu-Natal"
plot(region.tree)
```

To do this for the southern expansion, we'd need to select an animal each from *cynosuros* and *hilgerti*.

```{r,eval=F,echo=T}
keep.se<-c("VSAC1015","VSAB2012","VSAL3005","VSAF1015","VEA1008","VZA2006")
region.se.tree<-drop.tip(vervtree1,vervtree1$tip.label[-match(keep, vervtree1$tip.label)])
plot(region.se.tree)
region.se.tree$tip.label[region.se.tree$tip.label=="VSAC1015"] <- "FS North"
region.se.tree$tip.label[region.se.tree$tip.label=="VSAB2012"] <- "FS South"
region.se.tree$tip.label[region.se.tree$tip.label=="VSAL3005"] <- "Eastern Cape"
region.se.tree$tip.label[region.se.tree$tip.label=="VSAF1015"] <- "KwaZulu-Natal"
region.se.tree$tip.label[region.se.tree$tip.label=="VEA1008"] <- "Ethiopia"
region.se.tree$tip.label[region.se.tree$tip.label=="VZA2006"] <- "Zambia"
plot(region.se.tree)
```

##Climatic Data

Now, we need the climate data. Let's choose the following from the *WorldClim2* dataset:
<ul><li>BIO1 = Annual Mean Temperature</li>
<li>BIO4 = Temperature Seasonality (standard deviation *100)</li>
<li>BIO6 = Min Temperature of Coldest Month</li>
<li>BIO11 = Mean Temperature of Coldest Quarter</li>
</li></ul>

If we'd like to map these values, see the GIS analysis for *L. flavicauda* paper.

Now, before we go any further, we'll need GPS points for all of our sampled individuals.  As it happens, I've got them already for almost everyone, but we'll need to add *cynosuros* to this dataframe:
```{r,eval=F,echo=T}
verv.clim<-read.csv("~/Desktop/VervetOntoVariation/verv.climate.csv",header=T,sep=",")
```

HOWEVER, below is the code you'd need to get this on your own, if you had a file, `vervet.loc`, with Lat/Long in decimal degrees:

```{r,message=F,eval=F}
detach("package:dplyr", unload=TRUE)
library(raster)
climate<-getData('worldclim', var='bio', res=2.5)
coords<-data.frame(x=vervet.loc$Long,y=vervet.loc$Lat)
points<-SpatialPoints(coords, proj4string = climate@crs)
values<-extract(climate,points)
climate_new<-cbind.data.frame(vervet.loc$Animal_ID,coordinates(points),values)
colnames(climate_new)[1]<-"Animal_ID"
head(climate_new)
detach("package:raster", unload=TRUE)
```

We also need to keep in mind that the temperatures for the *WorldClim* database are multiplied by 10. Need to correct!

```{r,message=F,eval=F}
library(dplyr)
climate_new<-
  climate_new %>%
  mutate(bio1=bio1/10) %>%
  mutate(bio2=bio2/10) %>%
  mutate(bio5=bio5/10) %>%
  mutate(bio6=bio6/10) %>%
  mutate(bio7=bio7/10) %>%
  mutate(bio8=bio8/10) %>%
  mutate(bio9=bio9/10) %>%
  mutate(bio10=bio10/10) %>%
  mutate(bio11=bio11/10)
detach("package:dplyr", unload=TRUE)
```

Ok, now we can plot the points to climate maps across the world. For example, annual mean temperature:

```{r,message=FALSE,warning=FALSE,eval=F}
library(raster)
BIO6<-plot(climate$bio6, main="Min Temperature of Coldest Month")
BIO6
plot(points,add=T,pch=1,cex=0.5)
detach("package:raster", unload=TRUE)
```

Ok, now we can merge this novel `climate_new` dataframe with the previous dataframe so that the climate variables are accessible for our models:

```{r,message=FALSE,eval=F}
library(dplyr)
vervet.loc<-merge(vervet.loc,climate_new,by='Animal_ID')
vervet.loc<-droplevels(vervet.loc)
vervet.loc<-select(vervet.loc,-x,-y)
head(vervet.loc)
```

Let's print out one of these dataframes so that we can export the climate data to our published table:

```{r,eval=F}
write.csv(vervet.loc, file = "verv.climate.csv")
```

##Individual Vervet Genotypes

Ok, we've got the tree, we've got the covariates like latitude, altitude, and temperature, we've even got some potentially interesting covariates to look at like body mass. Now we just need the individual genotypes at each locus... 

To start with, let's just consider our three loci that are out of HWE and also appear to be experiencing selective sweeps in South Africa:
* 7:87483771 in the 3’ downstream region (A>G)
* 7:87493023 in intron 5-6 (G>A)
* 7:87496971 in intron 2-3 (A>G)

To get the genotype, we should just be able to pull out the ID and GT columns of the VCF file and import them into R, followed by a merge with the current database... let's see if it's that simple.

```{bash, eval = F, echo = T, class.source="sccCode"}
#Make sure the VCf is indexed:
module load tabix
tabix -p vcf pygUCP1.vcf.gz

module load bcftools
bcftools query -r CAE7:87483771,CAE7:87493023,CAE7:87496971 -f'[%CHROM %POS %REF %ALT [ %GT]\n]' pygUCP1.vcf.gz > UCP1_GT.INFO
```

OK! That worked. From there, I converted that file to a text file, imported it into Excel, and modifed it so that I have a simple count of ancestral and derived alleles for each of the three loci for each individual (in columns called, respectively, `der_87483771`, `der_87493023`, and `der_87496971` for derived ans `anc_etc` for ancestral). I've also added a column called 'region' which has the modifed regions I mention at the end of the tree-making exercise. From this, we should be able to both run our regressions and get at population-level allele frequencies for each.

Let's import this file:
```{r,eval=F,echo=T}
verv.genos<-read.csv("~/Desktop/vervAN333/snphylo/verv_ucp1_genotypes.csv",header=T,sep=",")
summary(verv.genos)
```

I've also made a file explicitly showing allele frequencies for each region, paired with climate data:
```{r,eval=F,echo=T}
verv.regfreq<-read.csv("~/Desktop/vervAN333/snphylo/ucp1_region_freq.csv",header=T,sep=",")
summary(verv.regfreq)
```

##Regressions Establishing Correlations with Environmental Covariates

Now, once we have this for the whole vervet population, we'll want to replicate the [Key et al., 2018](https://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1007298) analysis in the vervet sample. Their method was to chose a SNP of interest and to run a PGLS and GLMM with Null, Temp, Latitude, and Latitude + Temp. covariates compared using AIC, each assessed for cumulative probability. Mean Temp was average over 2000-2010 period for a .5x.5 km quadrat encompassing mean datapoint for a population (we can do this using *WorldClim2* dataset in {raster}, and use other indicators like winter cold temp etc, as in [Turner et al., 2018](). They also look at blocks of high F<sub>ST</sub> between groups as an indicator of selection across groups at that locus, as well as XP-EHH and iHS. Their figures show derived allele frequency per population regressed against latitude, and as a 3D surface with derived allele frequency on Y, and latitude and mean Temp as X/Z.

Their assessment of the population/selection history of the locus was far more complex, but not outside our reach, and they used several statistics we can calculate within an Approximate Bayesian Computation approach to compare and assess these models.

For PGLS (used `pgls` in {caper}): response variable is mean derived allele frequency for each population (can calculate), while the phylogeny was used as a random effect. In this paper, they used genome-wide F<sub>ST</sub> to construct a matrix of distances and from that construct a NJ tree. We'll use genome-wide SNP data to construct a phylogenetic tree. Predictor variables were Z-transformed since they were in different units. They tested the stability of the model for overall prediction by removing one population at a time and seeing if results remained stable. They used a likelihood ratio test between models with different sets of predictors to establish the best model (essentially an information theoretic approach).

For GLMM (done in {lme4}): response variable is a matrix of each individuals' genotype at the locus in each population as a two-column response matrix (count ancestral, count derived). Genetic distance was included as a fixed effect (genome-wide F<sub>ST</sub>-based distance from YRI), individual nested within population ID as random effects, with Temp and Latitude as variable fixed effects for model selection.

Ok, let's construct some models!

###PGLS Models of Derived Genotype Frequency by Latitude and Temperature

Oh, and one more variable to perhaps take into account: the sunbathing reported by Danzy et al. 2010. Perhaps we can include solar radiation in our model...  let's try using the POWER data from NASA/POWER SRB/FLASHFlux/MERRA2/GEOS 5.12.4 (FP-IT) 0.5 x 0.5 Degree Daily Averaged Data ("These data were obtained from the NASA Langley Research Center (LaRC) POWER Project funded through the NASA Earth Science/Applied Science Program."). I've downloaded them from NASA's website for each of four sites (Soetdoring for FS North, Gariep Dam for FS South, Zinkwazi for KZN, and Shamwari for EC). These represent the 10-year average (2005-2015) insolation in MJ/m^2/day during the coldest quarter (June-August, or day 152-243) for each site. They've been added directly to the `ucp1_region_freq` file, under the column `insol`.

First, we need to split up our dataframe by SNP, reframe our 'region' variable as row names and z-normalize our variables:
```{r,eval=F,echo=T}
library(tidyverse)
verv.reg.data<-tbl_df(verv.regfreq)

#for 7:87483771...
snp1<-verv.reg.data %>%
  filter(snp=="87483771")

#for 7:87493023...
snp2<-verv.reg.data %>%
  filter(snp=="87493023")

#for 7:87496971...
snp3<-verv.reg.data %>%
  filter(snp=="87496971")

snp1<-snp1 %>%
  mutate(zlat=scale(lat,center = TRUE, scale = TRUE)) %>%
  mutate(zalt=scale(altitude,center = TRUE, scale = TRUE)) %>%
  mutate(zbio1=scale(bio1,center = TRUE, scale = TRUE)) %>%
  mutate(zbio6=scale(bio6,center = TRUE, scale = TRUE)) %>%
  mutate(zbio11=scale(bio11,center = TRUE, scale = TRUE)) %>%
  mutate(zinsol=scale(insol,center = TRUE, scale = TRUE)) %>%
  column_to_rownames("region")
snp2<-snp2 %>%
  mutate(zlat=scale(lat,center = TRUE, scale = TRUE)) %>%
  mutate(zalt=scale(altitude,center = TRUE, scale = TRUE)) %>%
  mutate(zbio1=scale(bio1,center = TRUE, scale = TRUE)) %>%
  mutate(zbio6=scale(bio6,center = TRUE, scale = TRUE)) %>%
  mutate(zbio11=scale(bio11,center = TRUE, scale = TRUE)) %>%
  mutate(zinsol=scale(insol,center = TRUE, scale = TRUE)) %>%
  column_to_rownames("region")
snp3<-snp3 %>%
  mutate(zlat=scale(lat,center = TRUE, scale = TRUE)) %>%
  mutate(zalt=scale(altitude,center = TRUE, scale = TRUE)) %>%
  mutate(zbio1=scale(bio1,center = TRUE, scale = TRUE)) %>%
  mutate(zbio6=scale(bio6,center = TRUE, scale = TRUE)) %>%
  mutate(zbio11=scale(bio11,center = TRUE, scale = TRUE)) %>%
  mutate(zinsol=scale(insol,center = TRUE, scale = TRUE)) %>%
  column_to_rownames("region")
```

####Allele Freq Correlations with Geo/Climatic Variables

Let's take a quick look at our variables and see how they scale:
```{r,eval=F,echo=T}
library(ggplot2)
library(gridExtra)
snp1_lat<-ggplot(snp1, aes(lat,freq_derived)) + geom_point() + geom_text(aes(label=rownames(snp1)))+theme_bw()+ggtitle("Derived Freq by Latitude\nCAE7:87483771")

snp1_alt<-ggplot(snp1, aes(altitude,freq_derived)) + geom_point() + geom_text(aes(label=rownames(snp1)))+theme_bw()+ggtitle("Derived Freq by Altitude\nCAE7:87483771")

snp1_insol<-ggplot(snp1, aes(insol,freq_derived)) + geom_point() + geom_text(aes(label=rownames(snp1)))+theme_bw()+ggtitle("Derived Freq by Insolation\nCAE7:87483771")

snp1_bio1<-ggplot(snp1, aes(bio1,freq_derived)) + geom_point() + geom_text(aes(label=rownames(snp1)))+theme_bw()+ggtitle("Derived Freq by Avg Temp\nCAE7:87483771")

snp1_bio6<-ggplot(snp1, aes(bio6,freq_derived)) + geom_point() + geom_text(aes(label=rownames(snp1)))+theme_bw()+ggtitle("Derived Freq by\nMin Temp Coldest Month\nCAE7:87483771")

snp1_bio11<-ggplot(snp1, aes(bio11,freq_derived)) + geom_point() + geom_text(aes(label=rownames(snp1)))+theme_bw()+ggtitle("Derived Freq by Winter Temp\nCAE7:87483771")

snp2_lat<-ggplot(snp2, aes(lat,freq_derived)) + geom_point() + geom_text(aes(label=rownames(snp2)))+theme_bw()+ggtitle("Derived Freq by Latitude\nCAE7:87493023")

snp2_alt<-ggplot(snp2, aes(altitude,freq_derived)) + geom_point() + geom_text(aes(label=rownames(snp2)))+theme_bw()+ggtitle("Derived Freq by Altitude\nCAE7:87493023")

snp2_insol<-ggplot(snp2, aes(insol,freq_derived)) + geom_point() + geom_text(aes(label=rownames(snp2)))+theme_bw()+ggtitle("Derived Freq by Insolation\nCAE7:87493023")

snp2_bio1<-ggplot(snp2, aes(bio1,freq_derived)) + geom_point() + geom_text(aes(label=rownames(snp2)))+theme_bw()+ggtitle("Derived Freq by Avg Temp\nCAE7:87493023")

snp2_bio6<-ggplot(snp2, aes(bio6,freq_derived)) + geom_point() + geom_text(aes(label=rownames(snp2)))+theme_bw()+ggtitle("Derived Freq by\nMin Temp Coldest Month\nCAE7:87493023")

snp2_bio11<-ggplot(snp2, aes(bio11,freq_derived)) + geom_point() + geom_text(aes(label=rownames(snp2)))+theme_bw()+ggtitle("Derived Freq by Winter Temp\nCAE7:87493023")

snp3_lat<-ggplot(snp3, aes(lat,freq_derived)) + geom_point() + geom_text(aes(label=rownames(snp3)))+theme_bw()+ggtitle("Derived Freq by Latitude\nCAE7:87496971")

snp3_alt<-ggplot(snp3, aes(altitude,freq_derived)) + geom_point() + geom_text(aes(label=rownames(snp3)))+theme_bw()+ggtitle("Derived Freq by Altitude\nCAE7:87496971")

snp3_insol<-ggplot(snp3, aes(insol,freq_derived)) + geom_point() + geom_text(aes(label=rownames(snp3)))+theme_bw()+ggtitle("Derived Freq by Insolation\nCAE7:87496971")

snp3_bio1<-ggplot(snp3, aes(bio1,freq_derived)) + geom_point() + geom_text(aes(label=rownames(snp3)))+theme_bw()+ggtitle("Derived Freq by Avg Temp\nCAE7:87496971")

snp3_bio6<-ggplot(snp3, aes(bio6,freq_derived)) + geom_point() + geom_text(aes(label=rownames(snp3)))+theme_bw()+ggtitle("Derived Freq by\nMin Temp Coldest Month\nCAE7:87496971")

snp3_bio11<-ggplot(snp3, aes(bio11,freq_derived)) + geom_point() + geom_text(aes(label=rownames(snp3)))+theme_bw()+ggtitle("Derived Freq by Winter Temp\nCAE7:87496971")

snpcorr<-grid.arrange(grobs=list(snp1_lat,snp1_alt,snp1_insol,snp1_bio1,snp1_bio6,snp1_bio11,snp2_lat,snp1_alt,snp2_insol,snp2_bio1,snp2_bio6,snp2_bio11,snp3_lat,snp1_alt,snp3_insol,snp3_bio1,snp3_bio6,snp3_bio11),ncol=6,nrow=3,gp=gpar(fontsize=20,font=3))
ggsave("SNP_Correlations.tiff",snpcorr,width=20,height=9,dpi=600)
```

Ok, everything looks like it's going in the right direction, meaning that there are opposite trends for derived/ancestral frequencies from Free State (colder regions) to EC/KZN (warmer regions), but not quite in the tight line that would give us a good result.  Interestingly, only one SNP shows an increase in derived allele frequencies with colder conditions (snp2), while the others show the ancestral allele to be higher with colder conditions (snp1,snp3).

Let's do the PGLS model first:
```{r,eval=F,echo=T}
library(nlme)
#First we'll make sure our tree and data match up:
name.check(region.tree,snp1)
name.check(region.tree,snp2)
name.check(region.tree,snp3)
```


####PGLS Models for SNP1 (CAE7:87483771)
```{r,eval=F,echo=T}
pgls.snp1.null<-gls(freq_derived ~ 1, correlation = corBrownian(phy = region.tree),
    data = snp1, method = "ML")
summary(pgls.snp1.null)

pgls.snp1.temp<-gls(freq_derived ~ zbio6, correlation = corBrownian(phy = region.tree),
    data = snp1, method = "ML")
summary(pgls.snp1.temp)

pgls.snp1.lat<-gls(freq_derived ~ zlat, correlation = corBrownian(phy = region.tree),
    data = snp1, method = "ML")
summary(pgls.snp1.lat)

pgls.snp1.alt<-gls(freq_derived ~ zalt, correlation = corBrownian(phy = region.tree),
    data = snp1, method = "ML")
summary(pgls.snp1.alt)

pgls.snp1.insol<-gls(freq_derived ~ zinsol, correlation = corBrownian(phy = region.tree),
    data = snp1, method = "ML")
summary(pgls.snp1.insol)

pgls.snp1.templat<-gls(freq_derived ~ zlat+zbio6, correlation = corBrownian(phy = region.tree),
    data = snp1, method = "ML")
summary(pgls.snp1.templat)

pgls.snp1.tempinsol<-gls(freq_derived ~ zinsol+zbio6, correlation = corBrownian(phy = region.tree),
    data = snp1, method = "ML")
summary(pgls.snp1.tempinsol)

pgls.snp1.latinsol<-gls(freq_derived ~ zlat+zinsol, correlation = corBrownian(phy = region.tree),
    data = snp1, method = "ML")
summary(pgls.snp1.latinsol)
```


####PGLS Models for SNP2 (CAE7:87493023)
```{r,eval=F,echo=T}
pgls.snp2.null<-gls(freq_derived ~ 1, correlation = corBrownian(phy = region.tree),
    data = snp2, method = "ML")
summary(pgls.snp2.null)

pgls.snp2.temp<-gls(freq_derived ~ zbio6, correlation = corBrownian(phy = region.tree),
    data = snp2, method = "ML")
summary(pgls.snp2.temp)

pgls.snp2.lat<-gls(freq_derived ~ zlat, correlation = corBrownian(phy = region.tree),
    data = snp2, method = "ML")
summary(pgls.snp2.lat)

pgls.snp2.alt<-gls(freq_derived ~ zalt, correlation = corBrownian(phy = region.tree),
    data = snp2, method = "ML")
summary(pgls.snp2.alt)

pgls.snp2.insol<-gls(freq_derived ~ zinsol, correlation = corBrownian(phy = region.tree),
    data = snp2, method = "ML")
summary(pgls.snp2.insol)

pgls.snp2.templat<-gls(freq_derived ~ zlat+zbio6, correlation = corBrownian(phy = region.tree),
    data = snp2, method = "ML")
summary(pgls.snp2.templat)

pgls.snp2.tempinsol<-gls(freq_derived ~ zinsol+zbio6, correlation = corBrownian(phy = region.tree),
    data = snp2, method = "ML")
summary(pgls.snp2.tempinsol)

pgls.snp2.latinsol<-gls(freq_derived ~ zlat+zinsol, correlation = corBrownian(phy = region.tree),
    data = snp2, method = "ML")
summary(pgls.snp2.latinsol)
```

####PGLS Models for SNP3 (CAE7:87496971)
```{r,eval=F,echo=T}
pgls.snp3.null<-gls(freq_derived ~ 1, correlation = corBrownian(phy = region.tree),
    data = snp3, method = "ML")
summary(pgls.snp3.null)

pgls.snp3.temp<-gls(freq_derived ~ bio6, correlation = corBrownian(phy = region.tree),
    data = snp3, method = "ML")
summary(pgls.snp3.temp)

pgls.snp3.lat<-gls(freq_derived ~ lat, correlation = corBrownian(phy = region.tree),
    data = snp3, method = "ML")
summary(pgls.snp3.lat)

pgls.snp3.alt<-gls(freq_derived ~ zalt, correlation = corBrownian(phy = region.tree),
    data = snp3, method = "ML")
summary(pgls.snp3.alt)

pgls.snp3.insol<-gls(freq_derived ~ insol, correlation = corBrownian(phy = region.tree),
    data = snp3, method = "ML")
summary(pgls.snp3.insol)

pgls.snp3.templat<-gls(freq_derived ~ lat+bio6, correlation = corBrownian(phy = region.tree),
    data = snp3, method = "ML")
summary(pgls.snp3.templat)

pgls.snp3.tempinsol<-gls(freq_derived ~ insol+bio6, correlation = corBrownian(phy = region.tree),
    data = snp3, method = "ML")
summary(pgls.snp3.tempinsol)

pgls.snp3.latinsol<-gls(freq_derived ~ lat+insol, correlation = corBrownian(phy = region.tree),
    data = snp3, method = "ML")
summary(pgls.snp3.latinsol)
```

So with PGLS as used here, and with our climate variable being *bio6* or minimum temperature of the coldest month, there is definitely a pattern in the SNPs, with higher or lower residual frequency of the derived allele in Free State monkeys vs non-FS monkeys, but these are all showing up as non-significant. 

Problems with this analysis include that we're analyzing frequency as if it were continuous when it is in fact bounded by 0 and 1... we really should be using a GLM with a quasibinomial or beta error structure here. Also, these are underpowered... can't include more than two covariates! Hopefully this will improve with the addition of the *hilgerti* and *cynosuros* populations.

##GLMMs of Individual Genotypes by Latitude and Temperature

Let's try the GLMMs, as used in the Key et al. 2018 paper.

For GLMM (done in {lme4}): response variable is a matrix of each individuals' genotype at the locus in each population as a two-column response matrix (count ancestral, count derived; just like in the VCF file). Genetic distance was included as a fixed effect (genome-wide F<sub>ST</sub>-based distance from YRI), individual nested within population ID as random effects, with Temp and Latitude as variable fixed effects for model selection.

Hmmm... this is complicated... I would prefer to use the tree as a random effect, like PGLMM, but these are difficult to parameterize, I think I'd have to use MCMCglmm, which would require a shift to Bayesian methods (which hasn't stopped me before)... so let's try that rather than this F<sub>ST</sub> method.

First, we need to merge our `verv.genos` file with our `verv.clim` file. We can merge them based on our `Animal_ID` variable, which we'll also rename as `phylo` for later. Let's do that, but clean up our dataframes first (there are some overlapping variable names!):
```{r,eval=F,echo=T}
verv.clim2<-verv.clim %>%
  select(Animal_ID,Sex,Group,Weight_kg,Body_Length,Lat,Long,Altitude,bio1,bio4,bio6,bio11)

verv.glmm<-merge(verv.genos,verv.clim2,by='Animal_ID')

verv.glmm<-verv.glmm %>%
  mutate(zlat=scale(Lat,center = TRUE, scale = TRUE)) %>%
  mutate(zalt=scale(Altitude,center = TRUE, scale = TRUE)) %>%
  mutate(zbio1=scale(bio1,center = TRUE, scale = TRUE)) %>%
  mutate(zbio4=scale(bio4,center = TRUE, scale = TRUE)) %>%
  mutate(zbio6=scale(bio6,center = TRUE, scale = TRUE)) %>%
  mutate(zbio11=scale(bio11,center = TRUE, scale = TRUE)) %>%
  rename(phylo=Animal_ID)
```

Now, the original paper created a separate matrix of alleles, but we don't have to do this... we can simply use `cbind` to link the allele columns in the response variable. From there, we'll construct our model along the lines outlined by the paper with a few differences: major differences is that we'll use our phylogeny as a random effect (rather than F<sub>ST</sub> distances as a fixed effect), and will also nest ID in pop as a random effect, with our environmental variables as fixed effects. Let's start with just latitude and bio6 as our fixed effects.

First, we need to alter our tree a bit so that it can be used in our model:
```{r,eval=F,echo=T}
#First, we need to convert our tree to ultrametric (all tips equal in length), using {ape}
library(ape)
vervet.sau<-chronos(vervet.sa)
#make sure it's ultrametric now (it is)
is.ultrametric(vervet.sau)
#And there's a funky thing where we have to rewrite the tree for it to work (don't ask me why)
vervet.sau <- read.tree(text=write.tree(vervet.sau))

inv.phylo<-inverseA(vervet.sau,nodes="TIPS",scale=TRUE)
```

Also, for MCMCglmm to work, we need the level names of the taxa in the dataframe to be set as in the same order as the tip labels in our tree. Let’s do that now:
```{r,eval=F,echo=T}
#Here's the order of the tip labels:
vervet.sau$tip.label

#Here's how we line up our dataframe:
verv.glmm$phylo<-factor(verv.glmm$phylo,levels=c("VSAD1003","VSAJ2008","VSAA2015","VSAA2020","VSAA2010","VSAC1014","VSAC1015","VSAC1004","VSAC1016","VSAC1012","VSAB1003","VSAB5005","VSAB5004","VSAB2023","VSAB2010","VSAB2011","VSAB2009","VSAB3001","VSAB2017","VSAB3004","VSAB2012","VSAL5001","VSAL2002","VSAL4002","VSAM3001","VSAM1003","VSAL1001","VSAM5007","VSAM2001","VSAK3004","VSAL3005","VSAM0021","VSAM4001","VSAG2001","VSAG2005","VSAG2003","VSAH1001","VSAF1004","VSAF1012","VSAF1015","VSAF1011","VSAF1009","VSAE2011","VSAE2009","VSAE2005","VSAE3001","VSAE3003","VSAE3002","VSAI3005"))
```


Let's make sure the names between the tree and the dataframe are concordant:
```{r,eval=F,echo=T}
blah1<-inv.phylo$node.names
blah2<-levels(verv.glmm$phylo)
all(blah1 == blah2)
```

We also need to convert our dplyr data table back into a dataframe for MCMCglmm to read it properly:
```{r,eval=F,echo=T}
verv.glmm<-as.data.frame(verv.glmm)
```

And then, since we are conducting this analysis using a Bayesian framework, we need to establish our priors. In our case, we used canonical uninformative priors (inverse-Gamma distribution).

About Bayesian prior probabilities: this is where you give you best, informed, guess of what the data distribution is... `R` is the prior distribution of the residuals, `G` is the prior distribution from the random effects, and you can also suggest priors for the fixed effects (`B`; we won't do that here). Other variables include `nu`, which is a number from near-zero to 1 that expresses your confidence in your prior estimate (1 meaning VERY sure, in which cas eyour prior probability is considered very tightly; nearer to zero meaning not really, and so the parameters are 'looser').


```{r,eval=F,echo=T}
#Residual priors (R) is set as the inverse-Wishart, which is the weakest possible prior assumptions about residual distribution
prior<-list(G=list(G1=list(V=diag(2),n=0.002),
            G2=list(V=diag(2),fix=1)),
            R=list(V=diag(2),n=1,fix=1)) #most stable

prior<-list(G=list(G1=list(V=diag(2),n=0.002),
            G2=list(V=diag(2),n=0.002)),
            R=list(V=diag(2),n=1,fix=1))
```

Ok, let's do this for snp1:
```{r,eval=F,echo=T}
library(MCMCglmm)
snp1.m<-MCMCglmm(der_87483771~zlat*zbio6-1,random=~us(trait):region+us(trait):phylo,rcov=~us(trait):units,ginverse=list(phylo=inv.phylo$Ainv),family="categorical",data=verv.glmm,prior=prior,burnin=4000,thin=30,nitt=65000)
```

Ok, let's take a look at how our model did:
```{r,eval=F,echo=T}
plot(snp1.m$Sol)
```

Hmmm... the kind of wobble in the overall pattern here suggests autocorrelation, which isn't great.  An easier way to look at that is this plot:

```{r,eval=F,echo=T}
> plot.acfs <- function(x) {
+     n <- dim(x)[2]
+     par(mfrow=c(ceiling(n/2),2), mar=c(3,2,3,0))
+     for (i in 1:n) {
+         acf(x[,i], lag.max=100, main=colnames(x)[i])
+         grid()
+     }
+ }

plot.acfs(snp1.m$Sol)
```


THIS SECTION IS NOT YET FINISHED!




##TRASHED BUT MAYBE FUTURE USEFUL CODE

Ok, now we need to create a vervet phylogeny from the whole genome VCF files... let's try this:

```{r, eval = F}
library(gdsfmt)
library(SNPRelate)
```

Now, to use SNPRelate, the VCF file needs to be unzipped.  The vervet VCF is 43 GB! So make sure there's enough memory for this! Also, once the VCF is unzipped, we need to remove the "CAE" from the chromosome names.  We can do this using an `awk` command in Terminal:

```{bash, eval=F,class.scource="sccCode"}
cd ~/Desktop/vervPhylo/
awk '{gsub(/^CAE/,""); print}' allvervets.vcf > allvervets_nocae.vcf
```

```{r, eval = F}
setwd("~/Desktop/vervPhylo")
snpgdsVCF2GDS("allvervets_nocae.vcf","allvervets.gds")
snpgdsSummary("allvervets.gds")
genofile<-snpgdsOpen("allvervets.gds")
```

Now we'll prune our SNP set based on LD:
```{r, eval = F}
set.seed(1000)
snpset<-snpgdsLDpruning(genofile,ld.threshold=0.2)
snp.id<-unlist(snpset)
```

This essentially removed all SNPs that have linkage of 0.2 or above with other SNPs and chooses one representative SNP (VERY conservative, but will save us a LOT of computational size). This pares down the number of SNPs from ~60 million to 456,437. Here's the output:

>SNP pruning based on LD:
Excluding 1,789,146 SNPs on non-autosomes
Excluding 33,945 SNPs (monomorphic: TRUE, MAF: NaN, missing rate: NaN)
Working space: 163 samples, 60,960,265 SNPs
    using 1 (CPU) core
    sliding window: 500,000 basepairs, Inf SNPs
    |LD| threshold: 0.2
    method: composite
Chromosome 1: 0.77%, 21,735/2,819,578
Chromosome 2: 0.78%, 16,096/2,072,144
Chromosome 3: 0.70%, 16,134/2,294,739
Chromosome 4: 0.72%, 16,046/2,244,064
Chromosome 5: 0.71%, 13,301/1,861,091
Chromosome 6: 0.73%, 9,459/1,301,850
Chromosome 7: 0.74%, 23,686/3,208,435
Chromosome 8: 0.72%, 24,569/3,394,389
Chromosome 9: 0.75%, 22,241/2,968,307
Chromosome 10: 0.76%, 22,201/2,916,477
Chromosome 11: 0.76%, 22,394/2,933,533
Chromosome 12: 0.77%, 18,961/2,471,228
Chromosome 13: 0.76%, 17,168/2,269,995
Chromosome 14: 0.76%, 18,714/2,476,482
Chromosome 15: 0.75%, 16,132/2,153,167
Chromosome 16: 0.79%, 13,284/1,671,707
Chromosome 17: 0.73%, 12,878/1,772,114
Chromosome 18: 0.71%, 12,667/1,777,104
Chromosome 19: 0.71%, 5,933/834,899
Chromosome 20: 0.77%, 22,854/2,952,344
Chromosome 21: 0.75%, 22,135/2,937,584
Chromosome 22: 0.77%, 17,244/2,232,937
Chromosome 23: 0.75%, 14,234/1,896,950
Chromosome 24: 0.77%, 14,458/1,875,876
Chromosome 25: 0.76%, 14,886/1,947,842
Chromosome 26: 0.78%, 10,278/1,315,172
Chromosome 27: 0.70%, 8,548/1,224,911
Chromosome 28: 0.67%, 3,946/586,990
Chromosome 29: 0.73%, 4,255/582,301
456,437 markers are selected in total



